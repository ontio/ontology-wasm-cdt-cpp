!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACTION	eosio.hpp	20;"	d
ALIGNED	types.h	/^struct ALIGNED(capi_checksum160) {$/;"	f	signature:(capi_checksum160)
ALIGNED	types.h	/^struct ALIGNED(capi_checksum256) {$/;"	f	signature:(capi_checksum256)
ALIGNED	types.h	/^struct ALIGNED(capi_checksum512) {$/;"	f	signature:(capi_checksum512)
ALIGNED	types.h	31;"	d
CONTRACT	eosio.hpp	19;"	d
EOSIO_DISPATCH	dispatcher.hpp	116;"	d
EOSIO_DISPATCH_HELPER	dispatcher.hpp	98;"	d
EOSIO_DISPATCH_INTERNAL	dispatcher.hpp	92;"	d
EOSLIB_REFLECT_MEMBER_OP	serialize.hpp	7;"	d
EOSLIB_SERIALIZE	serialize.hpp	25;"	d
EOSLIB_SERIALIZE_DERIVED	serialize.hpp	46;"	d
INLINE_ACTION_SENDER	action.hpp	479;"	d
INLINE_ACTION_SENDER2	action.hpp	476;"	d
INLINE_ACTION_SENDER3	action.hpp	473;"	d
MAKE_TRAITS_FOR_ARITHMETIC_SECONDARY_KEY	multi_index.hpp	111;"	d
R	action.hpp	/^      auto get_args(R(Act::*p)(Args...)) {$/;"	f	namespace:eosio::detail	signature:(Act::*p)
R	action.hpp	/^      auto get_args_nounwrap(R(Act::*p)(Args...)) {$/;"	f	namespace:eosio::detail	signature:(Act::*p)
SEND_INLINE_ACTION	action.hpp	494;"	d
TABLE	eosio.hpp	21;"	d
WRAP_SECONDARY_ARRAY_TYPE	multi_index.hpp	84;"	d
WRAP_SECONDARY_SIMPLE_TYPE	multi_index.hpp	57;"	d
__addtf3	compiler_builtins.h	/^  void __addtf3( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__ashlti3	compiler_builtins.h	/^  void __ashlti3(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift);$/;"	p	signature:(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift)
__ashrti3	compiler_builtins.h	/^  void __ashrti3(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift);$/;"	p	signature:(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift)
__break_point	compiler_builtins.h	/^  void __break_point();$/;"	p	signature:()
__builtin_wasm_current_memory	eosiolib.cpp	/^   size_t __builtin_wasm_current_memory();$/;"	p	file:	signature:()
__builtin_wasm_grow_memory	eosiolib.cpp	/^   size_t __builtin_wasm_grow_memory(size_t);$/;"	p	file:	signature:(size_t)
__cmptf2	compiler_builtins.h	/^  int __cmptf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__divtf3	compiler_builtins.h	/^  void __divtf3( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__divti3	compiler_builtins.h	/^  void __divti3(__int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb);$/;"	p	signature:(__int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb)
__eqtf2	compiler_builtins.h	/^  int __eqtf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__extenddftf2	compiler_builtins.h	/^  void __extenddftf2( long double& ret, double f );$/;"	p	signature:( long double& ret, double f )
__extendsftf2	compiler_builtins.h	/^  void __extendsftf2( long double& ret, float f );$/;"	p	signature:( long double& ret, float f )
__fixtfdi	compiler_builtins.h	/^  int64_t __fixtfdi( uint64_t l, uint64_t h );$/;"	p	signature:( uint64_t l, uint64_t h )
__fixtfsi	compiler_builtins.h	/^  int32_t __fixtfsi( uint64_t l, uint64_t h );$/;"	p	signature:( uint64_t l, uint64_t h )
__fixunstfdi	compiler_builtins.h	/^  uint64_t __fixunstfdi( uint64_t l, uint64_t h );$/;"	p	signature:( uint64_t l, uint64_t h )
__fixunstfsi	compiler_builtins.h	/^  uint32_t __fixunstfsi( uint64_t l, uint64_t h );$/;"	p	signature:( uint64_t l, uint64_t h )
__getf2	compiler_builtins.h	/^  int __getf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__gttf2	compiler_builtins.h	/^  int __gttf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__idx	multi_index.hpp	/^         const multi_index* __idx;$/;"	m	struct:eosio::multi_index::item	access:public
__iters	multi_index.hpp	/^         int32_t            __iters[sizeof...(Indices)+(sizeof...(Indices)==0)];$/;"	m	struct:eosio::multi_index::item	access:public
__letf2	compiler_builtins.h	/^  int __letf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__lshlti3	compiler_builtins.h	/^  void __lshlti3(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift);$/;"	p	signature:(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift)
__lshrti3	compiler_builtins.h	/^  void __lshrti3(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift);$/;"	p	signature:(__int128& res, uint64_t lo, uint64_t hi, uint32_t shift)
__lttf2	compiler_builtins.h	/^  int __lttf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__modti3	compiler_builtins.h	/^  void __modti3(__int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb);$/;"	p	signature:(__int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb)
__multf3	compiler_builtins.h	/^  void __multf3( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__multi3	compiler_builtins.h	/^  void __multi3(__int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb);$/;"	p	signature:(__int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb)
__netf2	compiler_builtins.h	/^  int __netf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__primary_itr	multi_index.hpp	/^         int32_t            __primary_itr;$/;"	m	struct:eosio::multi_index::item	access:public
__subtf3	compiler_builtins.h	/^  void __subtf3( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( long double& ret, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
__trunctfdf2	compiler_builtins.h	/^  double __trunctfdf2( uint64_t l, uint64_t h );$/;"	p	signature:( uint64_t l, uint64_t h )
__trunctfsf2	compiler_builtins.h	/^  float __trunctfsf2( uint64_t l, uint64_t h );$/;"	p	signature:( uint64_t l, uint64_t h )
__udivti3	compiler_builtins.h	/^  void __udivti3(unsigned __int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb);$/;"	p	signature:(unsigned __int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb)
__umodti3	compiler_builtins.h	/^  void __umodti3(unsigned __int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb);$/;"	p	signature:(unsigned __int128& res, uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb)
__unordtf2	compiler_builtins.h	/^  int __unordtf2( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb );$/;"	p	signature:( uint64_t la, uint64_t ha, uint64_t lb, uint64_t hb )
_active_free_heap	eosiolib.cpp	/^      uint32_t _active_free_heap;$/;"	m	class:eosio::memory_manager	file:	access:private
_active_heap	eosiolib.cpp	/^      uint32_t _active_heap;$/;"	m	class:eosio::memory_manager	file:	access:private
_alloc_memory_mask	eosiolib.cpp	/^      static const uint32_t _alloc_memory_mask = uint32_t(1) << 31;$/;"	m	class:eosio::memory_manager	file:	access:private
_available_heaps	eosiolib.cpp	/^      memory _available_heaps[_heaps_size];$/;"	m	class:eosio::memory_manager	file:	access:private
_code	contract.hpp	/^      name _code;$/;"	m	class:eosio::contract	access:protected
_code	multi_index.hpp	/^      name     _code;$/;"	m	class:eosio::multi_index	access:private
_count	time.hpp	/^        int64_t _count;$/;"	m	class:eosio::microseconds	access:public
_data	binary_extension.hpp	/^         typename std::aligned_storage<sizeof(T), alignof(T)>::type _data;$/;"	m	class:eosio::binary_extension	access:private
_ds	contract.hpp	/^      datastream<const char*> _ds = datastream<const char*>(nullptr, 0);$/;"	m	class:eosio::contract	access:protected
_end	datastream.hpp	/^      T _end;$/;"	m	class:eosio::datastream	access:private
_get	binary_extension.hpp	/^         constexpr T& _get() {$/;"	f	class:eosio::binary_extension	access:private	signature:()
_get	binary_extension.hpp	/^         constexpr const T& _get()const {$/;"	f	class:eosio::binary_extension	access:private	signature:() const
_has_value	binary_extension.hpp	/^         bool _has_value = false;$/;"	m	class:eosio::binary_extension	access:private
_heap	eosiolib.cpp	/^         char* _heap;$/;"	m	class:eosio::memory_manager::memory	file:	access:private
_heap_end	eosiolib.cpp	/^            const char* const _heap_end;$/;"	m	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private
_heap_size	eosiolib.cpp	/^         uint32_t _heap_size;$/;"	m	class:eosio::memory_manager::memory	file:	access:private
_heaps_actual_size	eosiolib.cpp	/^      uint32_t _heaps_actual_size;$/;"	m	class:eosio::memory_manager	file:	access:private
_heaps_size	eosiolib.cpp	/^      static const uint32_t _heaps_size = 16;$/;"	m	class:eosio::memory_manager	file:	access:private
_idx	multi_index.hpp	/^                  const index* _idx;$/;"	m	struct:eosio::multi_index::index::const_iterator	access:private
_indices	multi_index.hpp	/^      indices_type _indices;$/;"	m	class:eosio::multi_index	access:private
_initial_heap	eosiolib.cpp	/^      char _initial_heap[_initial_heap_size];$/;"	m	class:eosio::memory_manager	file:	access:private
_initial_heap_size	eosiolib.cpp	/^      static const uint32_t _initial_heap_size = 8192;\/\/32768;$/;"	m	class:eosio::memory_manager	file:	access:private
_item	multi_index.hpp	/^                  const item*  _item;$/;"	m	struct:eosio::multi_index::index::const_iterator	access:private
_item	multi_index.hpp	/^            const item*        _item;$/;"	m	struct:eosio::multi_index::const_iterator	access:private
_item	multi_index.hpp	/^         std::unique_ptr<item> _item;$/;"	m	struct:eosio::multi_index::item_ptr	access:public
_items_vector	multi_index.hpp	/^      mutable std::vector<item_ptr> _items_vector;$/;"	m	class:eosio::multi_index	access:private
_mem_block	eosiolib.cpp	/^      static const uint32_t _mem_block = 8;$/;"	m	class:eosio::memory_manager	file:	access:private
_multidx	multi_index.hpp	/^            const multi_index* _multidx;$/;"	m	struct:eosio::multi_index::const_iterator	access:private
_multidx	multi_index.hpp	/^            typename std::conditional<IsConst, const multi_index*, multi_index*>::type _multidx;$/;"	m	struct:eosio::multi_index::index	access:private
_n	name.hpp	/^inline constexpr eosio::name operator""_n() {$/;"	f	signature:()
_next_primary_key	multi_index.hpp	/^      mutable uint64_t _next_primary_key;$/;"	m	class:eosio::multi_index	access:private
_offset	eosiolib.cpp	/^         uint32_t _offset;$/;"	m	class:eosio::memory_manager::memory	file:	access:private
_pos	datastream.hpp	/^      T _pos;$/;"	m	class:eosio::datastream	access:private
_primary_itr	multi_index.hpp	/^         int32_t               _primary_itr;$/;"	m	struct:eosio::multi_index::item_ptr	access:public
_primary_key	multi_index.hpp	/^         uint64_t              _primary_key;$/;"	m	struct:eosio::multi_index::item_ptr	access:public
_ptr	eosiolib.cpp	/^            char* _ptr;$/;"	m	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private
_rem_mem_block_mask	eosiolib.cpp	/^      static const uint32_t _rem_mem_block_mask = _mem_block - 1;$/;"	m	class:eosio::memory_manager	file:	access:private
_scope	multi_index.hpp	/^      uint64_t _scope;$/;"	m	class:eosio::multi_index	access:private
_self	contract.hpp	/^      name _self;$/;"	m	class:eosio::contract	access:protected
_size	datastream.hpp	/^     size_t _size;$/;"	m	class:eosio::datastream	access:private
_size	eosiolib.cpp	/^            uint32_t _size;$/;"	m	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private
_size_marker	eosiolib.cpp	/^      static const uint32_t _size_marker = sizeof(uint32_t);$/;"	m	class:eosio::memory_manager	file:	access:private
_start	datastream.hpp	/^      T _start;$/;"	m	class:eosio::datastream	access:private
_t	singleton.hpp	/^         table _t;$/;"	m	class:eosio::singleton	access:private
account	action.hpp	/^      name                       account;$/;"	m	struct:eosio::action	access:public
action	action.hpp	/^      action( const permission_level& auth, struct name a, struct name n, T&& value )$/;"	f	struct:eosio::action	access:public	signature:( const permission_level& auth, struct name a, struct name n, T&& value )
action	action.hpp	/^      action( std::vector<permission_level> auths, struct name a, struct name n, T&& value )$/;"	f	struct:eosio::action	access:public	signature:( std::vector<permission_level> auths, struct name a, struct name n, T&& value )
action	action.hpp	/^      action() = default;$/;"	p	struct:eosio::action	access:public	signature:()
action	action.hpp	/^   struct action {$/;"	s	namespace:eosio
action_data_size	action.h	/^   uint32_t action_data_size();$/;"	p	signature:()
action_name	action.hpp	/^      static constexpr eosio::name action_name = eosio::name(Name);$/;"	m	struct:eosio::action_wrapper	access:public
action_name	action.hpp	/^      static constexpr eosio::name action_name = eosio::name(Name);$/;"	m	struct:eosio::variant_action_wrapper	access:public
action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, const eosio::permission_level& perm)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, const eosio::permission_level& perm)
action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, const std::vector<eosio::permission_level>& perms)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, const std::vector<eosio::permission_level>& perms)
action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, eosio::permission_level&& perm)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, eosio::permission_level&& perm)
action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, std::vector<eosio::permission_level>&& perms)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, std::vector<eosio::permission_level>&& perms)
action_wrapper	action.hpp	/^   struct action_wrapper {$/;"	s	namespace:eosio
actions	transaction.hpp	/^      std::vector<action>  actions;$/;"	m	class:eosio::transaction	access:public
actor	action.hpp	/^      name    actor;$/;"	m	struct:eosio::permission_level	access:public
adjust_to_mem_block	eosiolib.cpp	/^      void adjust_to_mem_block(uint32_t& size)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(uint32_t& size)
alloca	memory.hpp	/^extern "C" void* alloca(size_t);$/;"	p	signature:(size_t)
amount	asset.hpp	/^      int64_t      amount = 0;$/;"	m	struct:eosio::asset	access:public
arr_itr	fixed_bytes.hpp	/^               arr_itr += num_sub_words;$/;"	m	namespace:eosio	typeref:class:eosio::fixed_bytes
assert_recover_key	crypto.cpp	/^   void assert_recover_key( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey ) {$/;"	f	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey )
assert_recover_key	crypto.h	/^void assert_recover_key( const capi_checksum256* digest, const char* sig, size_t siglen, const char* pub, size_t publen );$/;"	p	signature:( const capi_checksum256* digest, const char* sig, size_t siglen, const char* pub, size_t publen )
assert_recover_key	crypto.hpp	/^   void assert_recover_key( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey );$/;"	p	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey )
assert_ripemd160	crypto.cpp	/^   void assert_ripemd160( const char* data, uint32_t length, const eosio::checksum160& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
assert_ripemd160	crypto.h	/^void assert_ripemd160( const char* data, uint32_t length, const capi_checksum160* hash );$/;"	p	signature:( const char* data, uint32_t length, const capi_checksum160* hash )
assert_ripemd160	crypto.hpp	/^   void assert_ripemd160( const char* data, uint32_t length, const eosio::checksum160& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
assert_sha1	crypto.cpp	/^   void assert_sha1( const char* data, uint32_t length, const eosio::checksum160& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
assert_sha1	crypto.h	/^void assert_sha1( const char* data, uint32_t length, const capi_checksum160* hash );$/;"	p	signature:( const char* data, uint32_t length, const capi_checksum160* hash )
assert_sha1	crypto.hpp	/^   void assert_sha1( const char* data, uint32_t length, const eosio::checksum160& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
assert_sha256	crypto.cpp	/^   void assert_sha256( const char* data, uint32_t length, const eosio::checksum256& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum256& hash )
assert_sha256	crypto.h	/^void assert_sha256( const char* data, uint32_t length, const capi_checksum256* hash );$/;"	p	signature:( const char* data, uint32_t length, const capi_checksum256* hash )
assert_sha256	crypto.hpp	/^   void assert_sha256( const char* data, uint32_t length, const eosio::checksum256& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum256& hash )
assert_sha512	crypto.cpp	/^   void assert_sha512( const char* data, uint32_t length, const eosio::checksum512& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum512& hash )
assert_sha512	crypto.h	/^void assert_sha512( const char* data, uint32_t length, const capi_checksum512* hash );$/;"	p	signature:( const char* data, uint32_t length, const capi_checksum512* hash )
assert_sha512	crypto.hpp	/^   void assert_sha512( const char* data, uint32_t length, const eosio::checksum512& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum512& hash )
asset	asset.hpp	/^      asset( int64_t a, class symbol s )$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a, class symbol s )
asset	asset.hpp	/^      asset() {}$/;"	f	struct:eosio::asset	access:public	signature:()
asset	asset.hpp	/^   struct asset {$/;"	s	namespace:eosio
authorization	action.hpp	/^      std::vector<permission_level>   authorization;$/;"	m	struct:eosio::action	access:public
available_primary_key	multi_index.hpp	/^      uint64_t available_primary_key()const {$/;"	f	class:eosio::multi_index	access:public	signature:() const
base_per_transaction_net_usage	privileged.hpp	/^      uint32_t base_per_transaction_net_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
begin	multi_index.hpp	/^            const_iterator begin()const  { return cbegin(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
begin	multi_index.hpp	/^      const_iterator begin()const  { return cbegin(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
binary_extension	binary_extension.hpp	/^         constexpr binary_extension( T&& ext )$/;"	f	class:eosio::binary_extension	access:public	signature:( T&& ext )
binary_extension	binary_extension.hpp	/^         constexpr binary_extension( binary_extension&& other )$/;"	f	class:eosio::binary_extension	access:public	signature:( binary_extension&& other )
binary_extension	binary_extension.hpp	/^         constexpr binary_extension( const T& ext )$/;"	f	class:eosio::binary_extension	access:public	signature:( const T& ext )
binary_extension	binary_extension.hpp	/^         constexpr binary_extension( const binary_extension& other )$/;"	f	class:eosio::binary_extension	access:public	signature:( const binary_extension& other )
binary_extension	binary_extension.hpp	/^         constexpr binary_extension( std::in_place_t, Args&&... args )$/;"	f	class:eosio::binary_extension	access:public	signature:( std::in_place_t, Args&&... args )
binary_extension	binary_extension.hpp	/^         constexpr binary_extension() {}$/;"	f	class:eosio::binary_extension	access:public	signature:()
binary_extension	binary_extension.hpp	/^   class binary_extension {$/;"	c	namespace:eosio
block_interval_ms	time.hpp	/^         static constexpr int32_t block_interval_ms = 500;$/;"	m	class:eosio::block_timestamp	access:public
block_signing_key	privileged.hpp	/^      public_key       block_signing_key;$/;"	m	struct:eosio::producer_key	access:public
block_timestamp	time.hpp	/^         block_timestamp(const time_point& t) {$/;"	f	class:eosio::block_timestamp	access:public	signature:(const time_point& t)
block_timestamp	time.hpp	/^         block_timestamp(const time_point_sec& t) {$/;"	f	class:eosio::block_timestamp	access:public	signature:(const time_point_sec& t)
block_timestamp	time.hpp	/^         explicit block_timestamp( uint32_t s=0 ) :slot(s){}$/;"	f	class:eosio::block_timestamp	access:public	signature:( uint32_t s=0 )
block_timestamp	time.hpp	/^   class block_timestamp {$/;"	c	namespace:eosio
block_timestamp_epoch	time.hpp	/^         static constexpr int64_t block_timestamp_epoch = 946684800000ll;  \/\/ epoch is year 2000$/;"	m	class:eosio::block_timestamp	access:public
block_timestamp_type	time.hpp	/^   typedef block_timestamp block_timestamp_type;$/;"	t	namespace:eosio
blockchain_parameters	privileged.hpp	/^   struct blockchain_parameters {$/;"	s	namespace:eosio
bool_pack	fixed_bytes.hpp	/^         template<bool...> struct bool_pack;$/;"	x
bool_pack	fixed_key.hpp	/^         template<bool...> struct bool_pack;$/;"	x
buffer_ptr	eosiolib.cpp	/^            buffer_ptr(void* ptr, const char* const heap_end)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(void* ptr, const char* const heap_end)
buffer_ptr	eosiolib.cpp	/^            buffer_ptr(void* ptr, uint32_t buff_size, const char* const heap_end)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(void* ptr, uint32_t buff_size, const char* const heap_end)
buffer_ptr	eosiolib.cpp	/^         class buffer_ptr$/;"	c	class:eosio::memory_manager::memory	file:	access:private
call	action.hpp	/^      static void call(name code, const permission_level& perm, std::tuple<Args...> args) {$/;"	f	struct:eosio::inline_dispatcher	access:public	signature:(name code, const permission_level& perm, std::tuple<Args...> args)
call	action.hpp	/^      static void call(name code, std::vector<permission_level> perms, std::tuple<Args...> args) {$/;"	f	struct:eosio::inline_dispatcher	access:public	signature:(name code, std::vector<permission_level> perms, std::tuple<Args...> args)
calloc	eosiolib.cpp	/^   friend void* ::calloc(size_t count, size_t size);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(size_t count, size_t size)
calloc	eosiolib.cpp	/^void* calloc(size_t count, size_t size)$/;"	f	signature:(size_t count, size_t size)
calloc	memory.hpp	/^void* calloc(size_t count, size_t size);$/;"	p	signature:(size_t count, size_t size)
cancel_deferred	transaction.h	/^   int cancel_deferred(const uint128_t& sender_id);$/;"	p	signature:(const uint128_t& sender_id)
capi_name	types.h	/^typedef uint64_t capi_name;$/;"	t
capi_public_key	types.h	/^struct capi_public_key {$/;"	s
capi_public_key::data	types.h	/^   char data[34];$/;"	m	struct:capi_public_key	access:public
capi_signature	types.h	/^struct capi_signature {$/;"	s
capi_signature::data	types.h	/^   uint8_t data[66];$/;"	m	struct:capi_signature	access:public
cbegin	multi_index.hpp	/^            const_iterator cbegin()const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
cbegin	multi_index.hpp	/^      const_iterator cbegin()const {$/;"	f	class:eosio::multi_index	access:public	signature:() const
cend	multi_index.hpp	/^            const_iterator cend()const   { return const_iterator( this ); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
cend	multi_index.hpp	/^      const_iterator cend()const   { return const_iterator( this ); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
char_to_value	name.hpp	/^      static constexpr uint8_t char_to_value( char c ) {$/;"	f	struct:eosio::name	access:public	signature:( char c )
check	system.hpp	/^   inline void check(bool pred, const char* msg) {$/;"	f	namespace:eosio	signature:(bool pred, const char* msg)
check	system.hpp	/^   inline void check(bool pred, const char* msg, size_t n) {$/;"	f	namespace:eosio	signature:(bool pred, const char* msg, size_t n)
check	system.hpp	/^   inline void check(bool pred, const std::string& msg) {$/;"	f	namespace:eosio	signature:(bool pred, const std::string& msg)
check	system.hpp	/^   inline void check(bool pred, const std::string& msg, size_t n) {$/;"	f	namespace:eosio	signature:(bool pred, const std::string& msg, size_t n)
check	system.hpp	/^   inline void check(bool pred, std::string&& msg) {$/;"	f	namespace:eosio	signature:(bool pred, std::string&& msg)
check	system.hpp	/^   inline void check(bool pred, uint64_t code) {$/;"	f	namespace:eosio	signature:(bool pred, uint64_t code)
check_permission_authorization	permission.h	/^   check_permission_authorization( capi_name account,$/;"	p	signature:( capi_name account, capi_name permission, const char* pubkeys_data, uint32_t pubkeys_size, const char* perms_data, uint32_t perms_size, uint64_t delay_us )
check_permission_authorization	permission.hpp	/^   check_permission_authorization( name                               account,$/;"	f	namespace:eosio	signature:( name account, name permission, const std::set<public_key>& provided_keys, const std::set<permission_level>& provided_permissions = std::set<permission_level>(), uint64_t provided_delay_us = static_cast<uint64_t>(std::numeric_limits<int64_t>::max()) )
check_transaction_authorization	permission.h	/^   check_transaction_authorization( const char* trx_data,     uint32_t trx_size,$/;"	p	signature:( const char* trx_data, uint32_t trx_size, const char* pubkeys_data, uint32_t pubkeys_size, const char* perms_data, uint32_t perms_size )
check_transaction_authorization	permission.hpp	/^   check_transaction_authorization( const transaction&                 trx,$/;"	f	namespace:eosio	signature:( const transaction& trx, const std::set<permission_level>& provided_permissions , const std::set<public_key>& provided_keys = std::set<public_key>() )
check_types	action.hpp	/^      struct check_types {$/;"	s	namespace:eosio::detail
check_types	action.hpp	/^      struct check_types<Action, I, T> {$/;"	s	namespace:eosio::detail
cleanup_remaining	eosiolib.cpp	/^         void cleanup_remaining()$/;"	f	class:eosio::memory_manager::memory	access:public	signature:()
code	symbol.hpp	/^      constexpr symbol_code code()const              { return symbol_code{value >> 8};   }$/;"	f	class:eosio::symbol	access:public	signature:() const
code_name	action.hpp	/^      eosio::name code_name;$/;"	m	struct:eosio::action_wrapper	access:public
code_name	action.hpp	/^      eosio::name code_name;$/;"	m	struct:eosio::variant_action_wrapper	access:public
const_iterator	multi_index.hpp	/^                  const_iterator( const index* idx, const item* i = nullptr )$/;"	f	struct:eosio::multi_index::index::const_iterator	access:private	signature:( const index* idx, const item* i = nullptr )
const_iterator	multi_index.hpp	/^                  const_iterator():_item(nullptr){}$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:()
const_iterator	multi_index.hpp	/^            const_iterator( const multi_index* mi, const item* i = nullptr )$/;"	f	struct:eosio::multi_index::const_iterator	access:private	signature:( const multi_index* mi, const item* i = nullptr )
const_iterator	multi_index.hpp	/^            struct const_iterator : public std::iterator<std::bidirectional_iterator_tag, const T> {$/;"	s	struct:eosio::multi_index::index	inherits:std::iterator	access:public
const_iterator	multi_index.hpp	/^      struct const_iterator : public std::iterator<std::bidirectional_iterator_tag, const T> {$/;"	s	class:eosio::multi_index	inherits:std::iterator	access:public
const_mem_fun	multi_index.hpp	/^struct const_mem_fun$/;"	s	namespace:eosio
const_reverse_iterator	multi_index.hpp	/^            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:eosio::multi_index::index	access:public
const_reverse_iterator	multi_index.hpp	/^      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:eosio::multi_index	access:public
constants	multi_index.hpp	/^            enum constants {$/;"	g	struct:eosio::multi_index::index	access:public
constants	multi_index.hpp	/^   enum constants { index_name   = static_cast<uint64_t>(IndexName) };$/;"	g	struct:eosio::indexed_by	access:public
context_free_actions	transaction.hpp	/^      std::vector<action>  context_free_actions;$/;"	m	class:eosio::transaction	access:public
context_free_discount_net_usage_den	privileged.hpp	/^      uint32_t context_free_discount_net_usage_den;$/;"	m	struct:eosio::blockchain_parameters	access:public
context_free_discount_net_usage_num	privileged.hpp	/^      uint32_t context_free_discount_net_usage_num;$/;"	m	struct:eosio::blockchain_parameters	access:public
contract	asset.hpp	/^      name contract;$/;"	m	struct:eosio::extended_asset	access:public
contract	contract.hpp	/^      contract( name receiver, name code, datastream<const char*> ds ):_self(receiver),_code(code),_ds(ds) {}$/;"	f	class:eosio::contract	access:public	signature:( name receiver, name code, datastream<const char*> ds )
contract	contract.hpp	/^class contract {$/;"	c	namespace:eosio
contract	symbol.hpp	/^      name   contract; \/\/\/< the token contract hosting the symbol$/;"	m	class:eosio::extended_symbol	access:private
convert	action.hpp	/^      struct convert { typedef T type; };$/;"	s	namespace:eosio::detail
convert	action.hpp	/^      struct convert<char*> { typedef std::string type; };$/;"	s	namespace:eosio::detail
convert	action.hpp	/^      struct convert<const char*> { typedef std::string type; };$/;"	s	namespace:eosio::detail
count	time.hpp	/^        int64_t count()const { return _count; }$/;"	f	class:eosio::microseconds	access:public	signature:() const
cout	print.hpp	/^   static iostream cout;$/;"	m	namespace:eosio
crbegin	multi_index.hpp	/^            const_reverse_iterator crbegin()const { return std::make_reverse_iterator(cend()); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
crbegin	multi_index.hpp	/^      const_reverse_iterator crbegin()const { return std::make_reverse_iterator(cend()); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
crend	multi_index.hpp	/^            const_reverse_iterator crend()const   { return std::make_reverse_iterator(cbegin()); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
crend	multi_index.hpp	/^      const_reverse_iterator crend()const   { return std::make_reverse_iterator(cbegin()); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
current_receiver	action.h	/^   capi_name current_receiver();$/;"	p	signature:()
current_time	system.h	/^   uint64_t  current_time();$/;"	p	signature:()
data	action.hpp	/^      std::vector<char>               data;$/;"	m	struct:eosio::action	access:public
data	crypto.hpp	/^      std::array<char,33> data;$/;"	m	struct:eosio::public_key	access:public
data	crypto.hpp	/^      std::array<char,65> data;$/;"	m	struct:eosio::signature	access:public
data	types.h	/^   char data[34];$/;"	m	struct:capi_public_key	access:public
data	types.h	/^   uint8_t data[66];$/;"	m	struct:capi_signature	access:public
data_as	action.hpp	/^      T data_as() {$/;"	f	struct:eosio::action	access:public	signature:()
datastream	datastream.hpp	/^      datastream( T start, size_t s )$/;"	f	class:eosio::datastream	access:public	signature:( T start, size_t s )
datastream	datastream.hpp	/^     datastream( size_t init_size = 0):_size(init_size){}$/;"	f	class:eosio::datastream	access:public	signature:( size_t init_size = 0)
datastream	datastream.hpp	/^class datastream {$/;"	c	namespace:eosio
datastream	datastream.hpp	/^class datastream<size_t> {$/;"	c	namespace:eosio
days	time.hpp	/^  inline microseconds days(int64_t d) { return hours(24*d); }$/;"	f	namespace:eosio	signature:(int64_t d)
db_end_i64	db.h	/^int32_t db_end_i64(capi_name code, uint64_t scope, capi_name table);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table)
db_find_i64	db.h	/^int32_t db_find_i64(capi_name code, uint64_t scope, capi_name table, uint64_t id);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint64_t id)
db_get_i64	db.h	/^int32_t db_get_i64(int32_t iterator, const void* data, uint32_t len);$/;"	p	signature:(int32_t iterator, const void* data, uint32_t len)
db_idx128_end	db.h	/^int32_t db_idx128_end(capi_name code, uint64_t scope, capi_name table);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table)
db_idx128_find_primary	db.h	/^int32_t db_idx128_find_primary(capi_name code, uint64_t scope, capi_name table, uint128_t* secondary, uint64_t primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint128_t* secondary, uint64_t primary)
db_idx128_find_secondary	db.h	/^int32_t db_idx128_find_secondary(capi_name code, uint64_t scope, capi_name table, const uint128_t* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, const uint128_t* secondary, uint64_t* primary)
db_idx128_lowerbound	db.h	/^int32_t db_idx128_lowerbound(capi_name code, uint64_t scope, capi_name table, uint128_t* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint128_t* secondary, uint64_t* primary)
db_idx128_next	db.h	/^int32_t db_idx128_next(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx128_previous	db.h	/^int32_t db_idx128_previous(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx128_remove	db.h	/^void db_idx128_remove(int32_t iterator);$/;"	p	signature:(int32_t iterator)
db_idx128_store	db.h	/^int32_t db_idx128_store(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const uint128_t* secondary);$/;"	p	signature:(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const uint128_t* secondary)
db_idx128_update	db.h	/^void db_idx128_update(int32_t iterator, capi_name payer, const uint128_t* secondary);$/;"	p	signature:(int32_t iterator, capi_name payer, const uint128_t* secondary)
db_idx128_upperbound	db.h	/^int32_t db_idx128_upperbound(capi_name code, uint64_t scope, capi_name table, uint128_t* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint128_t* secondary, uint64_t* primary)
db_idx256_end	db.h	/^int32_t db_idx256_end(capi_name code, uint64_t scope, capi_name table);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table)
db_idx256_find_primary	db.h	/^int32_t db_idx256_find_primary(capi_name code, uint64_t scope, capi_name table, uint128_t* data, uint32_t data_len, uint64_t primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint128_t* data, uint32_t data_len, uint64_t primary)
db_idx256_find_secondary	db.h	/^int32_t db_idx256_find_secondary(capi_name code, uint64_t scope, capi_name table, const uint128_t* data, uint32_t data_len, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, const uint128_t* data, uint32_t data_len, uint64_t* primary)
db_idx256_lowerbound	db.h	/^int32_t db_idx256_lowerbound(capi_name code, uint64_t scope, capi_name table, uint128_t* data, uint32_t data_len, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint128_t* data, uint32_t data_len, uint64_t* primary)
db_idx256_next	db.h	/^int32_t db_idx256_next(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx256_previous	db.h	/^int32_t db_idx256_previous(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx256_remove	db.h	/^void db_idx256_remove(int32_t iterator);$/;"	p	signature:(int32_t iterator)
db_idx256_store	db.h	/^int32_t db_idx256_store(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const uint128_t* data, uint32_t data_len );$/;"	p	signature:(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const uint128_t* data, uint32_t data_len )
db_idx256_update	db.h	/^void db_idx256_update(int32_t iterator, capi_name payer, const uint128_t* data, uint32_t data_len);$/;"	p	signature:(int32_t iterator, capi_name payer, const uint128_t* data, uint32_t data_len)
db_idx256_upperbound	db.h	/^int32_t db_idx256_upperbound(capi_name code, uint64_t scope, capi_name table, uint128_t* data, uint32_t data_len, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint128_t* data, uint32_t data_len, uint64_t* primary)
db_idx64_end	db.h	/^int32_t db_idx64_end(capi_name code, uint64_t scope, capi_name table);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table)
db_idx64_find_primary	db.h	/^int32_t db_idx64_find_primary(capi_name code, uint64_t scope, capi_name table, uint64_t* secondary, uint64_t primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint64_t* secondary, uint64_t primary)
db_idx64_find_secondary	db.h	/^int32_t db_idx64_find_secondary(capi_name code, uint64_t scope, capi_name table, const uint64_t* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, const uint64_t* secondary, uint64_t* primary)
db_idx64_lowerbound	db.h	/^int32_t db_idx64_lowerbound(capi_name code, uint64_t scope, capi_name table, uint64_t* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint64_t* secondary, uint64_t* primary)
db_idx64_next	db.h	/^int32_t db_idx64_next(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx64_previous	db.h	/^int32_t db_idx64_previous(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx64_remove	db.h	/^void db_idx64_remove(int32_t iterator);$/;"	p	signature:(int32_t iterator)
db_idx64_store	db.h	/^int32_t db_idx64_store(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const uint64_t* secondary);$/;"	p	signature:(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const uint64_t* secondary)
db_idx64_update	db.h	/^void db_idx64_update(int32_t iterator, capi_name payer, const uint64_t* secondary);$/;"	p	signature:(int32_t iterator, capi_name payer, const uint64_t* secondary)
db_idx64_upperbound	db.h	/^int32_t db_idx64_upperbound(capi_name code, uint64_t scope, capi_name table, uint64_t* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint64_t* secondary, uint64_t* primary)
db_idx_double_end	db.h	/^int32_t db_idx_double_end(capi_name code, uint64_t scope, capi_name table);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table)
db_idx_double_find_primary	db.h	/^int32_t db_idx_double_find_primary(capi_name code, uint64_t scope, capi_name table, double* secondary, uint64_t primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, double* secondary, uint64_t primary)
db_idx_double_find_secondary	db.h	/^int32_t db_idx_double_find_secondary(capi_name code, uint64_t scope, capi_name table, const double* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, const double* secondary, uint64_t* primary)
db_idx_double_lowerbound	db.h	/^int32_t db_idx_double_lowerbound(capi_name code, uint64_t scope, capi_name table, double* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, double* secondary, uint64_t* primary)
db_idx_double_next	db.h	/^int32_t db_idx_double_next(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx_double_previous	db.h	/^int32_t db_idx_double_previous(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx_double_remove	db.h	/^void db_idx_double_remove(int32_t iterator);$/;"	p	signature:(int32_t iterator)
db_idx_double_store	db.h	/^int32_t db_idx_double_store(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const double* secondary);$/;"	p	signature:(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const double* secondary)
db_idx_double_update	db.h	/^void db_idx_double_update(int32_t iterator, capi_name payer, const double* secondary);$/;"	p	signature:(int32_t iterator, capi_name payer, const double* secondary)
db_idx_double_upperbound	db.h	/^int32_t db_idx_double_upperbound(capi_name code, uint64_t scope, capi_name table, double* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, double* secondary, uint64_t* primary)
db_idx_long_double_end	db.h	/^int32_t db_idx_long_double_end(capi_name code, uint64_t scope, capi_name table);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table)
db_idx_long_double_find_primary	db.h	/^int32_t db_idx_long_double_find_primary(capi_name code, uint64_t scope, capi_name table, long double* secondary, uint64_t primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, long double* secondary, uint64_t primary)
db_idx_long_double_find_secondary	db.h	/^int32_t db_idx_long_double_find_secondary(capi_name code, uint64_t scope, capi_name table, const long double* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, const long double* secondary, uint64_t* primary)
db_idx_long_double_lowerbound	db.h	/^int32_t db_idx_long_double_lowerbound(capi_name code, uint64_t scope, capi_name table, long double* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, long double* secondary, uint64_t* primary)
db_idx_long_double_next	db.h	/^int32_t db_idx_long_double_next(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx_long_double_previous	db.h	/^int32_t db_idx_long_double_previous(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_idx_long_double_remove	db.h	/^void db_idx_long_double_remove(int32_t iterator);$/;"	p	signature:(int32_t iterator)
db_idx_long_double_store	db.h	/^int32_t db_idx_long_double_store(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const long double* secondary);$/;"	p	signature:(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const long double* secondary)
db_idx_long_double_update	db.h	/^void db_idx_long_double_update(int32_t iterator, capi_name payer, const long double* secondary);$/;"	p	signature:(int32_t iterator, capi_name payer, const long double* secondary)
db_idx_long_double_upperbound	db.h	/^int32_t db_idx_long_double_upperbound(capi_name code, uint64_t scope, capi_name table, long double* secondary, uint64_t* primary);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, long double* secondary, uint64_t* primary)
db_lowerbound_i64	db.h	/^int32_t db_lowerbound_i64(capi_name code, uint64_t scope, capi_name table, uint64_t id);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint64_t id)
db_next_i64	db.h	/^int32_t db_next_i64(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_previous_i64	db.h	/^int32_t db_previous_i64(int32_t iterator, uint64_t* primary);$/;"	p	signature:(int32_t iterator, uint64_t* primary)
db_remove_i64	db.h	/^void db_remove_i64(int32_t iterator);$/;"	p	signature:(int32_t iterator)
db_store_i64	db.h	/^int32_t db_store_i64(uint64_t scope, capi_name table, capi_name payer, uint64_t id,  const void* data, uint32_t len);$/;"	p	signature:(uint64_t scope, capi_name table, capi_name payer, uint64_t id, const void* data, uint32_t len)
db_update_i64	db.h	/^void db_update_i64(int32_t iterator, capi_name payer, const void* data, uint32_t len);$/;"	p	signature:(int32_t iterator, capi_name payer, const void* data, uint32_t len)
db_upperbound_i64	db.h	/^int32_t db_upperbound_i64(capi_name code, uint64_t scope, capi_name table, uint64_t id);$/;"	p	signature:(capi_name code, uint64_t scope, capi_name table, uint64_t id)
deferred_trx_expiration_window	privileged.hpp	/^      uint32_t deferred_trx_expiration_window;$/;"	m	struct:eosio::blockchain_parameters	access:public
delay_sec	transaction.hpp	/^      unsigned_int    delay_sec = 0UL; \/\/\/ number of seconds to delay transaction, default: 0$/;"	m	class:eosio::transaction_header	access:public
deserialize	datastream.hpp	/^void deserialize(datastream<Stream>& ds, std::variant<Ts...>& var, int i) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::variant<Ts...>& var, int i)
dispatch	dispatcher.hpp	/^   bool dispatch( uint64_t code, uint64_t act ) {$/;"	f	namespace:eosio	signature:( uint64_t code, uint64_t act )
dispatch_inline	action.hpp	/^   void dispatch_inline( name code, name act,$/;"	f	namespace:eosio	signature:( name code, name act, std::vector<permission_level> perms, std::tuple<Args...> args )
e	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	g	struct:eosio::multi_index::intc	access:public
elapsed	time.hpp	/^        microseconds elapsed;$/;"	m	class:eosio::time_point	access:public
emplace	binary_extension.hpp	/^         T& emplace(Args&& ... args)& {$/;"	f	class:eosio::binary_extension	access:public	signature:(Args&& .... args)
emplace	multi_index.hpp	/^      const_iterator emplace( name payer, Lambda&& constructor ) {$/;"	f	class:eosio::multi_index	access:public	signature:( name payer, Lambda&& constructor )
end	eosiolib.cpp	/^            char* end() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
end	multi_index.hpp	/^            const_iterator end()const    { return cend(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
end	multi_index.hpp	/^      const_iterator end()const    { return cend(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::_datastream_detail::is_pointer	datastream.hpp	/^   constexpr bool is_pointer() {$/;"	f	namespace:eosio::_datastream_detail	signature:()
eosio::_datastream_detail::is_primitive	datastream.hpp	/^   constexpr bool is_primitive() {$/;"	f	namespace:eosio::_datastream_detail	signature:()
eosio::_multi_index_detail::hana	multi_index.hpp	/^   namespace hana = boost::hana;$/;"	x
eosio::_multi_index_detail::secondary_index_db_functions	multi_index.hpp	/^   struct secondary_index_db_functions;$/;"	x
eosio::_multi_index_detail::secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits;$/;"	x
eosio::_multi_index_detail::secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<double> {$/;"	s	namespace:eosio::_multi_index_detail
eosio::_multi_index_detail::secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<eosio::fixed_bytes<32>> {$/;"	s	namespace:eosio::_multi_index_detail
eosio::_multi_index_detail::secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<eosio::key256> {$/;"	s	namespace:eosio::_multi_index_detail
eosio::_multi_index_detail::secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<long double> {$/;"	s	namespace:eosio::_multi_index_detail
eosio::_multi_index_detail::secondary_key_traits::true_lowest	multi_index.hpp	/^      static constexpr double true_lowest() { return -std::numeric_limits<double>::infinity(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
eosio::_multi_index_detail::secondary_key_traits::true_lowest	multi_index.hpp	/^      static constexpr eosio::fixed_bytes<32> true_lowest() { return eosio::fixed_bytes<32>(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
eosio::_multi_index_detail::secondary_key_traits::true_lowest	multi_index.hpp	/^      static constexpr eosio::key256 true_lowest() { return eosio::key256(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
eosio::_multi_index_detail::secondary_key_traits::true_lowest	multi_index.hpp	/^      static constexpr long double true_lowest() { return -std::numeric_limits<long double>::infinity(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
eosio::action	action.hpp	/^   struct action {$/;"	s	namespace:eosio
eosio::action::account	action.hpp	/^      name                       account;$/;"	m	struct:eosio::action	access:public
eosio::action::action	action.hpp	/^      action( const permission_level& auth, struct name a, struct name n, T&& value )$/;"	f	struct:eosio::action	access:public	signature:( const permission_level& auth, struct name a, struct name n, T&& value )
eosio::action::action	action.hpp	/^      action( std::vector<permission_level> auths, struct name a, struct name n, T&& value )$/;"	f	struct:eosio::action	access:public	signature:( std::vector<permission_level> auths, struct name a, struct name n, T&& value )
eosio::action::action	action.hpp	/^      action() = default;$/;"	p	struct:eosio::action	access:public	signature:()
eosio::action::authorization	action.hpp	/^      std::vector<permission_level>   authorization;$/;"	m	struct:eosio::action	access:public
eosio::action::data	action.hpp	/^      std::vector<char>               data;$/;"	m	struct:eosio::action	access:public
eosio::action::data_as	action.hpp	/^      T data_as() {$/;"	f	struct:eosio::action	access:public	signature:()
eosio::action::name	action.hpp	/^      name                       name;$/;"	m	struct:eosio::action	access:public
eosio::action::send	action.hpp	/^      void send() const {$/;"	f	struct:eosio::action	access:public	signature:() const
eosio::action::send_context_free	action.hpp	/^      void send_context_free() const {$/;"	f	struct:eosio::action	access:public	signature:() const
eosio::action_wrapper	action.hpp	/^   struct action_wrapper {$/;"	s	namespace:eosio
eosio::action_wrapper::action_name	action.hpp	/^      static constexpr eosio::name action_name = eosio::name(Name);$/;"	m	struct:eosio::action_wrapper	access:public
eosio::action_wrapper::action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, const eosio::permission_level& perm)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, const eosio::permission_level& perm)
eosio::action_wrapper::action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, const std::vector<eosio::permission_level>& perms)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, const std::vector<eosio::permission_level>& perms)
eosio::action_wrapper::action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, eosio::permission_level&& perm)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, eosio::permission_level&& perm)
eosio::action_wrapper::action_wrapper	action.hpp	/^      constexpr action_wrapper(Code&& code, std::vector<eosio::permission_level>&& perms)$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Code&& code, std::vector<eosio::permission_level>&& perms)
eosio::action_wrapper::code_name	action.hpp	/^      eosio::name code_name;$/;"	m	struct:eosio::action_wrapper	access:public
eosio::action_wrapper::get_mem_ptr	action.hpp	/^      static constexpr auto get_mem_ptr() {$/;"	f	struct:eosio::action_wrapper	access:public	signature:()
eosio::action_wrapper::permissions	action.hpp	/^      std::vector<eosio::permission_level> permissions;$/;"	m	struct:eosio::action_wrapper	access:public
eosio::action_wrapper::send	action.hpp	/^      void send(Args&&... args)const {$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Args&&.... args) const
eosio::action_wrapper::send_context_free	action.hpp	/^      void send_context_free(Args&&... args)const {$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Args&&.... args) const
eosio::action_wrapper::to_action	action.hpp	/^      action to_action(Args&&... args)const {$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Args&&.... args) const
eosio::arr_itr	fixed_bytes.hpp	/^               arr_itr += num_sub_words;$/;"	m	namespace:eosio	typeref:class:eosio::fixed_bytes
eosio::assert_recover_key	crypto.cpp	/^   void assert_recover_key( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey ) {$/;"	f	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey )
eosio::assert_recover_key	crypto.hpp	/^   void assert_recover_key( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey );$/;"	p	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig, const eosio::public_key& pubkey )
eosio::assert_ripemd160	crypto.cpp	/^   void assert_ripemd160( const char* data, uint32_t length, const eosio::checksum160& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
eosio::assert_ripemd160	crypto.hpp	/^   void assert_ripemd160( const char* data, uint32_t length, const eosio::checksum160& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
eosio::assert_sha1	crypto.cpp	/^   void assert_sha1( const char* data, uint32_t length, const eosio::checksum160& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
eosio::assert_sha1	crypto.hpp	/^   void assert_sha1( const char* data, uint32_t length, const eosio::checksum160& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum160& hash )
eosio::assert_sha256	crypto.cpp	/^   void assert_sha256( const char* data, uint32_t length, const eosio::checksum256& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum256& hash )
eosio::assert_sha256	crypto.hpp	/^   void assert_sha256( const char* data, uint32_t length, const eosio::checksum256& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum256& hash )
eosio::assert_sha512	crypto.cpp	/^   void assert_sha512( const char* data, uint32_t length, const eosio::checksum512& hash ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum512& hash )
eosio::assert_sha512	crypto.hpp	/^   void assert_sha512( const char* data, uint32_t length, const eosio::checksum512& hash );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length, const eosio::checksum512& hash )
eosio::asset	asset.hpp	/^   struct asset {$/;"	s	namespace:eosio
eosio::asset::amount	asset.hpp	/^      int64_t      amount = 0;$/;"	m	struct:eosio::asset	access:public
eosio::asset::asset	asset.hpp	/^      asset( int64_t a, class symbol s )$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a, class symbol s )
eosio::asset::asset	asset.hpp	/^      asset() {}$/;"	f	struct:eosio::asset	access:public	signature:()
eosio::asset::is_amount_within_range	asset.hpp	/^      bool is_amount_within_range()const { return -max_amount <= amount && amount <= max_amount; }$/;"	f	struct:eosio::asset	access:public	signature:() const
eosio::asset::is_valid	asset.hpp	/^      bool is_valid()const               { return is_amount_within_range() && symbol.is_valid(); }$/;"	f	struct:eosio::asset	access:public	signature:() const
eosio::asset::max_amount	asset.hpp	/^      static constexpr int64_t max_amount    = (1LL << 62) - 1;$/;"	m	struct:eosio::asset	access:public
eosio::asset::operator !=	asset.hpp	/^      friend bool operator!=( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator *	asset.hpp	/^      friend asset operator*( const asset& a, int64_t b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, int64_t b )
eosio::asset::operator *	asset.hpp	/^      friend asset operator*( int64_t b, const asset& a ) {$/;"	f	struct:eosio::asset	access:friend	signature:( int64_t b, const asset& a )
eosio::asset::operator *=	asset.hpp	/^      asset& operator*=( int64_t a ) {$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a )
eosio::asset::operator +	asset.hpp	/^      inline friend asset operator+( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator +=	asset.hpp	/^      asset& operator+=( const asset& a ) {$/;"	f	struct:eosio::asset	access:public	signature:( const asset& a )
eosio::asset::operator -	asset.hpp	/^      asset operator-()const {$/;"	f	struct:eosio::asset	access:public	signature:() const
eosio::asset::operator -	asset.hpp	/^      inline friend asset operator-( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator -=	asset.hpp	/^      asset& operator-=( const asset& a ) {$/;"	f	struct:eosio::asset	access:public	signature:( const asset& a )
eosio::asset::operator /	asset.hpp	/^      friend asset operator\/( const asset& a, int64_t b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, int64_t b )
eosio::asset::operator /	asset.hpp	/^      friend int64_t operator\/( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator /=	asset.hpp	/^      asset& operator\/=( int64_t a ) {$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a )
eosio::asset::operator <	asset.hpp	/^      friend bool operator<( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator <=	asset.hpp	/^      friend bool operator<=( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator ==	asset.hpp	/^      friend bool operator==( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator >	asset.hpp	/^      friend bool operator>( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::operator >=	asset.hpp	/^      friend bool operator>=( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
eosio::asset::print	asset.hpp	/^      void print()const {$/;"	f	struct:eosio::asset	access:public	signature:() const
eosio::asset::set_amount	asset.hpp	/^      void set_amount( int64_t a ) {$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a )
eosio::asset::symbol	asset.hpp	/^      symbol  symbol;$/;"	m	struct:eosio::asset	access:public
eosio::asset::to_string	asset.hpp	/^      std::string to_string()const {$/;"	f	struct:eosio::asset	access:public	signature:() const
eosio::binary_extension	binary_extension.hpp	/^   class binary_extension {$/;"	c	namespace:eosio
eosio::binary_extension::_data	binary_extension.hpp	/^         typename std::aligned_storage<sizeof(T), alignof(T)>::type _data;$/;"	m	class:eosio::binary_extension	access:private
eosio::binary_extension::_get	binary_extension.hpp	/^         constexpr T& _get() {$/;"	f	class:eosio::binary_extension	access:private	signature:()
eosio::binary_extension::_get	binary_extension.hpp	/^         constexpr const T& _get()const {$/;"	f	class:eosio::binary_extension	access:private	signature:() const
eosio::binary_extension::_has_value	binary_extension.hpp	/^         bool _has_value = false;$/;"	m	class:eosio::binary_extension	access:private
eosio::binary_extension::binary_extension	binary_extension.hpp	/^         constexpr binary_extension( T&& ext )$/;"	f	class:eosio::binary_extension	access:public	signature:( T&& ext )
eosio::binary_extension::binary_extension	binary_extension.hpp	/^         constexpr binary_extension( binary_extension&& other )$/;"	f	class:eosio::binary_extension	access:public	signature:( binary_extension&& other )
eosio::binary_extension::binary_extension	binary_extension.hpp	/^         constexpr binary_extension( const T& ext )$/;"	f	class:eosio::binary_extension	access:public	signature:( const T& ext )
eosio::binary_extension::binary_extension	binary_extension.hpp	/^         constexpr binary_extension( const binary_extension& other )$/;"	f	class:eosio::binary_extension	access:public	signature:( const binary_extension& other )
eosio::binary_extension::binary_extension	binary_extension.hpp	/^         constexpr binary_extension( std::in_place_t, Args&&... args )$/;"	f	class:eosio::binary_extension	access:public	signature:( std::in_place_t, Args&&... args )
eosio::binary_extension::binary_extension	binary_extension.hpp	/^         constexpr binary_extension() {}$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::emplace	binary_extension.hpp	/^         T& emplace(Args&& ... args)& {$/;"	f	class:eosio::binary_extension	access:public	signature:(Args&& .... args)
eosio::binary_extension::has_value	binary_extension.hpp	/^         constexpr bool has_value()const { return _has_value; }$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::operator *	binary_extension.hpp	/^         constexpr T& operator*()& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::operator *	binary_extension.hpp	/^         constexpr T&& operator*()&& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::operator *	binary_extension.hpp	/^         constexpr const T& operator*()const& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::operator *	binary_extension.hpp	/^         constexpr const T&& operator*()const&& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::operator ->	binary_extension.hpp	/^         constexpr T* operator->() {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::operator ->	binary_extension.hpp	/^         constexpr const T* operator->()const {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::operator bool	binary_extension.hpp	/^         constexpr explicit operator bool()const { return _has_value; }$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::reset	binary_extension.hpp	/^         void reset() {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::value	binary_extension.hpp	/^         constexpr T& value()& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::value	binary_extension.hpp	/^         constexpr const T& value()const & {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::value_or	binary_extension.hpp	/^         constexpr T value_or()& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::value_or	binary_extension.hpp	/^         constexpr T value_or()const& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::value_or	binary_extension.hpp	/^         constexpr T&& value_or()&& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::binary_extension::value_or	binary_extension.hpp	/^         constexpr const T&& value_or()const&& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
eosio::binary_extension::~binary_extension	binary_extension.hpp	/^         ~binary_extension() { reset(); }$/;"	f	class:eosio::binary_extension	access:public	signature:()
eosio::block_timestamp	time.hpp	/^   class block_timestamp {$/;"	c	namespace:eosio
eosio::block_timestamp::block_interval_ms	time.hpp	/^         static constexpr int32_t block_interval_ms = 500;$/;"	m	class:eosio::block_timestamp	access:public
eosio::block_timestamp::block_timestamp	time.hpp	/^         block_timestamp(const time_point& t) {$/;"	f	class:eosio::block_timestamp	access:public	signature:(const time_point& t)
eosio::block_timestamp::block_timestamp	time.hpp	/^         block_timestamp(const time_point_sec& t) {$/;"	f	class:eosio::block_timestamp	access:public	signature:(const time_point_sec& t)
eosio::block_timestamp::block_timestamp	time.hpp	/^         explicit block_timestamp( uint32_t s=0 ) :slot(s){}$/;"	f	class:eosio::block_timestamp	access:public	signature:( uint32_t s=0 )
eosio::block_timestamp::block_timestamp_epoch	time.hpp	/^         static constexpr int64_t block_timestamp_epoch = 946684800000ll;  \/\/ epoch is year 2000$/;"	m	class:eosio::block_timestamp	access:public
eosio::block_timestamp::maximum	time.hpp	/^         static block_timestamp maximum() { return block_timestamp( 0xffff ); }$/;"	f	class:eosio::block_timestamp	access:public	signature:()
eosio::block_timestamp::min	time.hpp	/^         static block_timestamp min() { return block_timestamp(0); }$/;"	f	class:eosio::block_timestamp	access:public	signature:()
eosio::block_timestamp::next	time.hpp	/^         block_timestamp next() const {$/;"	f	class:eosio::block_timestamp	access:public	signature:() const
eosio::block_timestamp::operator !=	time.hpp	/^         bool   operator !=( const block_timestamp& t )const   { return slot != t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
eosio::block_timestamp::operator <	time.hpp	/^         bool   operator < ( const block_timestamp& t )const   { return slot <  t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
eosio::block_timestamp::operator <=	time.hpp	/^         bool   operator <=( const block_timestamp& t )const   { return slot <= t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
eosio::block_timestamp::operator =	time.hpp	/^         void operator = (const time_point& t ) {$/;"	f	class:eosio::block_timestamp	access:public	signature:(const time_point& t )
eosio::block_timestamp::operator ==	time.hpp	/^         bool   operator ==( const block_timestamp& t )const   { return slot == t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
eosio::block_timestamp::operator >	time.hpp	/^         bool   operator > ( const block_timestamp& t )const   { return slot >  t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
eosio::block_timestamp::operator >=	time.hpp	/^         bool   operator >=( const block_timestamp& t )const   { return slot >= t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
eosio::block_timestamp::operator time_point	time.hpp	/^         operator time_point() const {$/;"	f	class:eosio::block_timestamp	access:public	signature:() const
eosio::block_timestamp::set_time_point	time.hpp	/^      void set_time_point(const time_point& t) {$/;"	f	class:eosio::block_timestamp	access:private	signature:(const time_point& t)
eosio::block_timestamp::set_time_point	time.hpp	/^      void set_time_point(const time_point_sec& t) {$/;"	f	class:eosio::block_timestamp	access:private	signature:(const time_point_sec& t)
eosio::block_timestamp::slot	time.hpp	/^         uint32_t slot;$/;"	m	class:eosio::block_timestamp	access:public
eosio::block_timestamp::to_time_point	time.hpp	/^         time_point to_time_point() const {$/;"	f	class:eosio::block_timestamp	access:public	signature:() const
eosio::block_timestamp_type	time.hpp	/^   typedef block_timestamp block_timestamp_type;$/;"	t	namespace:eosio
eosio::blockchain_parameters	privileged.hpp	/^   struct blockchain_parameters {$/;"	s	namespace:eosio
eosio::blockchain_parameters::base_per_transaction_net_usage	privileged.hpp	/^      uint32_t base_per_transaction_net_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::context_free_discount_net_usage_den	privileged.hpp	/^      uint32_t context_free_discount_net_usage_den;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::context_free_discount_net_usage_num	privileged.hpp	/^      uint32_t context_free_discount_net_usage_num;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::deferred_trx_expiration_window	privileged.hpp	/^      uint32_t deferred_trx_expiration_window;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_authority_depth	privileged.hpp	/^      uint16_t max_authority_depth;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_block_cpu_usage	privileged.hpp	/^      uint32_t max_block_cpu_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_block_net_usage	privileged.hpp	/^      uint64_t max_block_net_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_inline_action_depth	privileged.hpp	/^      uint16_t max_inline_action_depth;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_inline_action_size	privileged.hpp	/^      uint32_t max_inline_action_size;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_transaction_cpu_usage	privileged.hpp	/^      uint32_t max_transaction_cpu_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_transaction_delay	privileged.hpp	/^      uint32_t max_transaction_delay;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_transaction_lifetime	privileged.hpp	/^      uint32_t max_transaction_lifetime;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::max_transaction_net_usage	privileged.hpp	/^      uint32_t max_transaction_net_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::min_transaction_cpu_usage	privileged.hpp	/^      uint32_t min_transaction_cpu_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::net_usage_leeway	privileged.hpp	/^      uint32_t net_usage_leeway;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::target_block_cpu_usage_pct	privileged.hpp	/^      uint32_t target_block_cpu_usage_pct;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::blockchain_parameters::target_block_net_usage_pct	privileged.hpp	/^      uint32_t target_block_net_usage_pct;$/;"	m	struct:eosio::blockchain_parameters	access:public
eosio::check	system.hpp	/^   inline void check(bool pred, const char* msg) {$/;"	f	namespace:eosio	signature:(bool pred, const char* msg)
eosio::check	system.hpp	/^   inline void check(bool pred, const char* msg, size_t n) {$/;"	f	namespace:eosio	signature:(bool pred, const char* msg, size_t n)
eosio::check	system.hpp	/^   inline void check(bool pred, const std::string& msg) {$/;"	f	namespace:eosio	signature:(bool pred, const std::string& msg)
eosio::check	system.hpp	/^   inline void check(bool pred, const std::string& msg, size_t n) {$/;"	f	namespace:eosio	signature:(bool pred, const std::string& msg, size_t n)
eosio::check	system.hpp	/^   inline void check(bool pred, std::string&& msg) {$/;"	f	namespace:eosio	signature:(bool pred, std::string&& msg)
eosio::check	system.hpp	/^   inline void check(bool pred, uint64_t code) {$/;"	f	namespace:eosio	signature:(bool pred, uint64_t code)
eosio::check_permission_authorization	permission.hpp	/^   check_permission_authorization( name                               account,$/;"	f	namespace:eosio	signature:( name account, name permission, const std::set<public_key>& provided_keys, const std::set<permission_level>& provided_permissions = std::set<permission_level>(), uint64_t provided_delay_us = static_cast<uint64_t>(std::numeric_limits<int64_t>::max()) )
eosio::check_transaction_authorization	permission.hpp	/^   check_transaction_authorization( const transaction&                 trx,$/;"	f	namespace:eosio	signature:( const transaction& trx, const std::set<permission_level>& provided_permissions , const std::set<public_key>& provided_keys = std::set<public_key>() )
eosio::const_mem_fun	multi_index.hpp	/^struct const_mem_fun$/;"	s	namespace:eosio
eosio::const_mem_fun::operator ()	multi_index.hpp	/^  Type operator()(const Class& x)const$/;"	f	struct:eosio::const_mem_fun	access:public	signature:(const Class& x) const
eosio::const_mem_fun::operator ()	multi_index.hpp	/^  Type operator()(const std::reference_wrapper<Class>& x)const$/;"	f	struct:eosio::const_mem_fun	access:public	signature:(const std::reference_wrapper<Class>& x) const
eosio::const_mem_fun::operator ()	multi_index.hpp	/^  Type operator()(const std::reference_wrapper<const Class>& x)const$/;"	f	struct:eosio::const_mem_fun	access:public	signature:(const std::reference_wrapper<const Class>& x) const
eosio::const_mem_fun::result_type	multi_index.hpp	/^  typedef typename std::remove_reference<Type>::type result_type;$/;"	t	struct:eosio::const_mem_fun	access:public
eosio::contract	contract.hpp	/^class contract {$/;"	c	namespace:eosio
eosio::contract::_code	contract.hpp	/^      name _code;$/;"	m	class:eosio::contract	access:protected
eosio::contract::_ds	contract.hpp	/^      datastream<const char*> _ds = datastream<const char*>(nullptr, 0);$/;"	m	class:eosio::contract	access:protected
eosio::contract::_self	contract.hpp	/^      name _self;$/;"	m	class:eosio::contract	access:protected
eosio::contract::contract	contract.hpp	/^      contract( name receiver, name code, datastream<const char*> ds ):_self(receiver),_code(code),_ds(ds) {}$/;"	f	class:eosio::contract	access:public	signature:( name receiver, name code, datastream<const char*> ds )
eosio::contract::get_code	contract.hpp	/^      inline name get_code()const { return _code; }$/;"	f	class:eosio::contract	access:public	signature:() const
eosio::contract::get_datastream	contract.hpp	/^      inline datastream<const char*> get_datastream()const { return _ds; }$/;"	f	class:eosio::contract	access:public	signature:() const
eosio::contract::get_self	contract.hpp	/^      inline name get_self()const { return _self; }$/;"	f	class:eosio::contract	access:public	signature:() const
eosio::cout	print.hpp	/^   static iostream cout;$/;"	m	namespace:eosio
eosio::datastream	datastream.hpp	/^class datastream {$/;"	c	namespace:eosio
eosio::datastream	datastream.hpp	/^class datastream<size_t> {$/;"	c	namespace:eosio
eosio::datastream::_end	datastream.hpp	/^      T _end;$/;"	m	class:eosio::datastream	access:private
eosio::datastream::_pos	datastream.hpp	/^      T _pos;$/;"	m	class:eosio::datastream	access:private
eosio::datastream::_size	datastream.hpp	/^     size_t _size;$/;"	m	class:eosio::datastream	access:private
eosio::datastream::_start	datastream.hpp	/^      T _start;$/;"	m	class:eosio::datastream	access:private
eosio::datastream::datastream	datastream.hpp	/^      datastream( T start, size_t s )$/;"	f	class:eosio::datastream	access:public	signature:( T start, size_t s )
eosio::datastream::datastream	datastream.hpp	/^     datastream( size_t init_size = 0):_size(init_size){}$/;"	f	class:eosio::datastream	access:public	signature:( size_t init_size = 0)
eosio::datastream::get	datastream.hpp	/^      inline bool get( char& c )$/;"	f	class:eosio::datastream	access:public	signature:( char& c )
eosio::datastream::get	datastream.hpp	/^      inline bool get( unsigned char& c ) { return get( *(char*)&c ); }$/;"	f	class:eosio::datastream	access:public	signature:( unsigned char& c )
eosio::datastream::pos	datastream.hpp	/^      T pos()const { return _pos; }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::put	datastream.hpp	/^      inline bool put(char c) {$/;"	f	class:eosio::datastream	access:public	signature:(char c)
eosio::datastream::put	datastream.hpp	/^     inline bool     put(char )                      { ++_size; return  true;    }$/;"	f	class:eosio::datastream	access:public	signature:(char )
eosio::datastream::read	datastream.hpp	/^      inline bool read( char* d, size_t s ) {$/;"	f	class:eosio::datastream	access:public	signature:( char* d, size_t s )
eosio::datastream::remaining	datastream.hpp	/^      inline size_t remaining()const  { return _end - _pos; }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::remaining	datastream.hpp	/^     inline size_t   remaining()const                 { return 0;                 }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::seekp	datastream.hpp	/^      inline bool seekp(size_t p) { _pos = _start + p; return _pos <= _end; }$/;"	f	class:eosio::datastream	access:public	signature:(size_t p)
eosio::datastream::seekp	datastream.hpp	/^     inline bool     seekp(size_t p)                  { _size = p;  return true;  }$/;"	f	class:eosio::datastream	access:public	signature:(size_t p)
eosio::datastream::skip	datastream.hpp	/^      inline void skip( size_t s ){ _pos += s; }$/;"	f	class:eosio::datastream	access:public	signature:( size_t s )
eosio::datastream::skip	datastream.hpp	/^     inline bool     skip( size_t s )                 { _size += s; return true;  }$/;"	f	class:eosio::datastream	access:public	signature:( size_t s )
eosio::datastream::tellp	datastream.hpp	/^      inline size_t tellp()const      { return size_t(_pos - _start); }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::tellp	datastream.hpp	/^     inline size_t   tellp()const                     { return _size;             }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::valid	datastream.hpp	/^      inline bool valid()const { return _pos <= _end && _pos >= _start;  }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::valid	datastream.hpp	/^     inline bool     valid()const                     { return true;              }$/;"	f	class:eosio::datastream	access:public	signature:() const
eosio::datastream::write	datastream.hpp	/^      inline bool write( const char* d, size_t s ) {$/;"	f	class:eosio::datastream	access:public	signature:( const char* d, size_t s )
eosio::datastream::write	datastream.hpp	/^     inline bool     write( const char* ,size_t s )  { _size += s; return true;  }$/;"	f	class:eosio::datastream	access:public	signature:( const char* ,size_t s )
eosio::days	time.hpp	/^  inline microseconds days(int64_t d) { return hours(24*d); }$/;"	f	namespace:eosio	signature:(int64_t d)
eosio::deserialize	datastream.hpp	/^void deserialize(datastream<Stream>& ds, std::variant<Ts...>& var, int i) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::variant<Ts...>& var, int i)
eosio::detail::R	action.hpp	/^      auto get_args(R(Act::*p)(Args...)) {$/;"	f	namespace:eosio::detail	signature:(Act::*p)
eosio::detail::R	action.hpp	/^      auto get_args_nounwrap(R(Act::*p)(Args...)) {$/;"	f	namespace:eosio::detail	signature:(Act::*p)
eosio::detail::check_types	action.hpp	/^      struct check_types {$/;"	s	namespace:eosio::detail
eosio::detail::check_types	action.hpp	/^      struct check_types<Action, I, T> {$/;"	s	namespace:eosio::detail
eosio::detail::check_types::static_assert	action.hpp	/^         static_assert(detail::is_same<typename convert<T>::type, typename convert<typename std::tuple_element<I, deduced<Action>>::type>::type>::value);$/;"	p	struct:eosio::detail::check_types	access:public	signature:(detail::is_same<typename convert<T>::type, typename convert<typename std::tuple_element<I, deduced<Action>>::type>::type>::value)
eosio::detail::check_types::value	action.hpp	/^         static constexpr bool value = true;$/;"	m	struct:eosio::detail::check_types	access:public
eosio::detail::convert	action.hpp	/^      struct convert { typedef T type; };$/;"	s	namespace:eosio::detail
eosio::detail::convert	action.hpp	/^      struct convert<char*> { typedef std::string type; };$/;"	s	namespace:eosio::detail
eosio::detail::convert	action.hpp	/^      struct convert<const char*> { typedef std::string type; };$/;"	s	namespace:eosio::detail
eosio::detail::convert::type	action.hpp	/^      struct convert { typedef T type; };$/;"	t	struct:eosio::detail::convert	access:public
eosio::detail::convert::type	action.hpp	/^      struct convert<char*> { typedef std::string type; };$/;"	t	struct:eosio::detail::convert	access:public
eosio::detail::convert::type	action.hpp	/^      struct convert<const char*> { typedef std::string type; };$/;"	t	struct:eosio::detail::convert	access:public
eosio::detail::get_nth	action.hpp	/^      struct get_nth { static constexpr auto value  = get_nth_impl<N,0,Args...>::value; };$/;"	s	namespace:eosio::detail
eosio::detail::get_nth::value	action.hpp	/^      struct get_nth { static constexpr auto value  = get_nth_impl<N,0,Args...>::value; };$/;"	m	struct:eosio::detail::get_nth	access:public
eosio::detail::get_nth_impl	action.hpp	/^      struct get_nth_impl { static constexpr auto value  = get_nth_impl<N,I+1,Args...>::value; };$/;"	s	namespace:eosio::detail
eosio::detail::get_nth_impl	action.hpp	/^      struct get_nth_impl<N, N, Arg, Args...> { static constexpr auto value = Arg; };$/;"	s	namespace:eosio::detail
eosio::detail::get_nth_impl::value	action.hpp	/^      struct get_nth_impl { static constexpr auto value  = get_nth_impl<N,I+1,Args...>::value; };$/;"	m	struct:eosio::detail::get_nth_impl	access:public
eosio::detail::get_nth_impl::value	action.hpp	/^      struct get_nth_impl<N, N, Arg, Args...> { static constexpr auto value = Arg; };$/;"	m	struct:eosio::detail::get_nth_impl	access:public
eosio::detail::is_same	action.hpp	/^      struct is_same { static constexpr bool value = std::is_convertible<T,U>::value; };$/;"	s	namespace:eosio::detail
eosio::detail::is_same	action.hpp	/^      struct is_same<T,bool> { static constexpr bool value = std::is_integral<T>::value; };$/;"	s	namespace:eosio::detail
eosio::detail::is_same	action.hpp	/^      struct is_same<bool,U> { static constexpr bool value = std::is_integral<U>::value; };$/;"	s	namespace:eosio::detail
eosio::detail::is_same::value	action.hpp	/^      struct is_same { static constexpr bool value = std::is_convertible<T,U>::value; };$/;"	m	struct:eosio::detail::is_same	access:public
eosio::detail::is_same::value	action.hpp	/^      struct is_same<T,bool> { static constexpr bool value = std::is_integral<T>::value; };$/;"	m	struct:eosio::detail::is_same	access:public
eosio::detail::is_same::value	action.hpp	/^      struct is_same<bool,U> { static constexpr bool value = std::is_integral<U>::value; };$/;"	m	struct:eosio::detail::is_same	access:public
eosio::detail::to_const_char_arr	name.hpp	/^      struct to_const_char_arr {$/;"	s	namespace:eosio::detail
eosio::detail::to_const_char_arr::value	name.hpp	/^         static constexpr const char value[] = {Str...};$/;"	m	struct:eosio::detail::to_const_char_arr	access:public
eosio::detail::type_check	action.hpp	/^      constexpr bool type_check() {$/;"	f	namespace:eosio::detail	signature:()
eosio::detail::unwrap	action.hpp	/^      struct unwrap { typedef T type; };$/;"	s	namespace:eosio::detail
eosio::detail::unwrap	action.hpp	/^      struct unwrap<ignore<T>> { typedef T type; };$/;"	s	namespace:eosio::detail
eosio::detail::unwrap::type	action.hpp	/^      struct unwrap { typedef T type; };$/;"	t	struct:eosio::detail::unwrap	access:public
eosio::detail::unwrap::type	action.hpp	/^      struct unwrap<ignore<T>> { typedef T type; };$/;"	t	struct:eosio::detail::unwrap	access:public
eosio::dispatch	dispatcher.hpp	/^   bool dispatch( uint64_t code, uint64_t act ) {$/;"	f	namespace:eosio	signature:( uint64_t code, uint64_t act )
eosio::dispatch_inline	action.hpp	/^   void dispatch_inline( name code, name act,$/;"	f	namespace:eosio	signature:( name code, name act, std::vector<permission_level> perms, std::tuple<Args...> args )
eosio::execute_action	dispatcher.hpp	/^   bool execute_action( name self, name code, void (T::*func)(Args...)  ) {$/;"	f	namespace:eosio	signature:( name self, name code, void (T::*func)(Args...) )
eosio::extended_asset	asset.hpp	/^   struct extended_asset {$/;"	s	namespace:eosio
eosio::extended_asset::contract	asset.hpp	/^      name contract;$/;"	m	struct:eosio::extended_asset	access:public
eosio::extended_asset::extended_asset	asset.hpp	/^      extended_asset( asset a, name c ):quantity(a),contract(c){}$/;"	f	struct:eosio::extended_asset	access:public	signature:( asset a, name c )
eosio::extended_asset::extended_asset	asset.hpp	/^      extended_asset( int64_t v, extended_symbol s ):quantity(v,s.get_symbol()),contract(s.get_contract()){}$/;"	f	struct:eosio::extended_asset	access:public	signature:( int64_t v, extended_symbol s )
eosio::extended_asset::extended_asset	asset.hpp	/^      extended_asset() = default;$/;"	p	struct:eosio::extended_asset	access:public	signature:()
eosio::extended_asset::get_extended_symbol	asset.hpp	/^      extended_symbol get_extended_symbol()const { return extended_symbol{ quantity.symbol, contract }; }$/;"	f	struct:eosio::extended_asset	access:public	signature:() const
eosio::extended_asset::operator !=	asset.hpp	/^      friend bool operator!=( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator +	asset.hpp	/^      friend extended_asset operator + ( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator +=	asset.hpp	/^      friend extended_asset& operator+=( extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator -	asset.hpp	/^      extended_asset operator-()const {$/;"	f	struct:eosio::extended_asset	access:public	signature:() const
eosio::extended_asset::operator -	asset.hpp	/^      friend extended_asset operator - ( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator -=	asset.hpp	/^      friend extended_asset& operator-=( extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator <	asset.hpp	/^      friend bool operator<( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator <=	asset.hpp	/^      friend bool operator<=( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator ==	asset.hpp	/^      friend bool operator==( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::operator >=	asset.hpp	/^      friend bool operator>=( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
eosio::extended_asset::print	asset.hpp	/^      void print()const {$/;"	f	struct:eosio::extended_asset	access:public	signature:() const
eosio::extended_asset::quantity	asset.hpp	/^      asset quantity;$/;"	m	struct:eosio::extended_asset	access:public
eosio::extended_symbol	symbol.hpp	/^   class extended_symbol$/;"	c	namespace:eosio
eosio::extended_symbol::contract	symbol.hpp	/^      name   contract; \/\/\/< the token contract hosting the symbol$/;"	m	class:eosio::extended_symbol	access:private
eosio::extended_symbol::extended_symbol	symbol.hpp	/^      constexpr extended_symbol( symbol sym, name con ) : symbol(sym), contract(con) {}$/;"	f	class:eosio::extended_symbol	access:public	signature:( symbol sym, name con )
eosio::extended_symbol::extended_symbol	symbol.hpp	/^      constexpr extended_symbol() {}$/;"	f	class:eosio::extended_symbol	access:public	signature:()
eosio::extended_symbol::get_contract	symbol.hpp	/^      constexpr name  get_contract() const { return contract; }$/;"	f	class:eosio::extended_symbol	access:public	signature:() const
eosio::extended_symbol::get_symbol	symbol.hpp	/^      constexpr symbol get_symbol() const { return symbol; }$/;"	f	class:eosio::extended_symbol	access:public	signature:() const
eosio::extended_symbol::operator !=	symbol.hpp	/^      friend constexpr bool operator != ( const extended_symbol& a, const extended_symbol& b ) {$/;"	f	class:eosio::extended_symbol	access:friend	signature:( const extended_symbol& a, const extended_symbol& b )
eosio::extended_symbol::operator <	symbol.hpp	/^      friend constexpr bool operator < ( const extended_symbol& a, const extended_symbol& b ) {$/;"	f	class:eosio::extended_symbol	access:friend	signature:( const extended_symbol& a, const extended_symbol& b )
eosio::extended_symbol::operator ==	symbol.hpp	/^      friend constexpr bool operator == ( const extended_symbol& a, const extended_symbol& b ) {$/;"	f	class:eosio::extended_symbol	access:friend	signature:( const extended_symbol& a, const extended_symbol& b )
eosio::extended_symbol::print	symbol.hpp	/^      void print( bool show_precision = true )const {$/;"	f	class:eosio::extended_symbol	access:public	signature:( bool show_precision = true ) const
eosio::extended_symbol::symbol	symbol.hpp	/^      symbol symbol; \/\/\/< the symbol$/;"	m	class:eosio::extended_symbol	access:private
eosio::extension	transaction.hpp	/^   typedef std::tuple<uint16_t, std::vector<char>> extension;$/;"	t	namespace:eosio
eosio::extensions_type	transaction.hpp	/^   typedef std::vector<extension> extensions_type;$/;"	t	namespace:eosio
eosio::fixed_bytes	fixed_bytes.hpp	/^   class fixed_bytes {$/;"	c	namespace:eosio
eosio::fixed_bytes	fixed_bytes.hpp	/^   class fixed_bytes;$/;"	x
eosio::fixed_bytes::bool_pack	fixed_bytes.hpp	/^         template<bool...> struct bool_pack;$/;"	x
eosio::fixed_bytes::fixed_bytes	fixed_bytes.hpp	/^         constexpr fixed_bytes() : _data() {}$/;"	f	class:eosio::fixed_bytes	access:public	signature:()
eosio::fixed_bytes::fixed_bytes	fixed_bytes.hpp	/^         fixed_bytes(const std::array<word_t, num_words()>& arr)$/;"	f	class:eosio::fixed_bytes	access:public	signature:(const std::array<word_t, num_words()>& arr)
eosio::fixed_bytes::num_words	fixed_bytes.hpp	/^         static constexpr size_t num_words() { return (Size + sizeof(word_t) - 1) \/ sizeof(word_t); }$/;"	f	class:eosio::fixed_bytes	access:public	signature:()
eosio::fixed_bytes::padded_bytes	fixed_bytes.hpp	/^         static constexpr size_t padded_bytes() { return num_words() * sizeof(word_t) - Size; }$/;"	f	class:eosio::fixed_bytes	access:public	signature:()
eosio::fixed_bytes::set_from_word_sequence	fixed_bytes.hpp	/^         static void set_from_word_sequence(const Word* arr_begin, const Word* arr_end, fixed_bytes<Size>& key)$/;"	f	class:eosio::fixed_bytes	access:private	signature:(const Word* arr_begin, const Word* arr_end, fixed_bytes<Size>& key)
eosio::fixed_bytes::word_t	fixed_bytes.hpp	/^         typedef uint128_t word_t;$/;"	t	class:eosio::fixed_bytes	access:public
eosio::fixed_key	fixed_key.hpp	/^   class [[deprecated("Replaced by fixed_bytes")]] fixed_key {$/;"	c	namespace:eosio
eosio::fixed_key	fixed_key.hpp	/^   class fixed_key;$/;"	x
eosio::fixed_key::bool_pack	fixed_key.hpp	/^         template<bool...> struct bool_pack;$/;"	x
eosio::fixed_key::fixed_key	fixed_key.hpp	/^         constexpr fixed_key() : _data() {}$/;"	f	class:eosio::fixed_key	access:public	signature:()
eosio::fixed_key::fixed_key	fixed_key.hpp	/^         fixed_key(const std::array<word_t, num_words()>& arr)$/;"	f	class:eosio::fixed_key	access:public	signature:(const std::array<word_t, num_words()>& arr)
eosio::fixed_key::num_words	fixed_key.hpp	/^         static constexpr size_t num_words() { return (Size + sizeof(word_t) - 1) \/ sizeof(word_t); }$/;"	f	class:eosio::fixed_key	access:public	signature:()
eosio::fixed_key::padded_bytes	fixed_key.hpp	/^         static constexpr size_t padded_bytes() { return num_words() * sizeof(word_t) - Size; }$/;"	f	class:eosio::fixed_key	access:public	signature:()
eosio::fixed_key::set_from_word_sequence	fixed_key.hpp	/^         static void set_from_word_sequence(Word* arr_begin, Word* arr_end, fixed_key<Size>& key)$/;"	f	class:eosio::fixed_key	access:private	signature:(Word* arr_begin, Word* arr_end, fixed_key<Size>& key)
eosio::fixed_key::word_t	fixed_key.hpp	/^         typedef uint128_t word_t;$/;"	t	class:eosio::fixed_key	access:public
eosio::fixed_point128	fixedpoint.hpp	/^    struct fixed_point128$/;"	s	namespace:eosio
eosio::fixed_point128	fixedpoint.hpp	/^    template <uint8_t Q> struct fixed_point128;$/;"	x
eosio::fixed_point32	fixedpoint.hpp	/^    template <uint8_t Q> struct fixed_point32;$/;"	x
eosio::fixed_point64	fixedpoint.hpp	/^    template <uint8_t Q> struct fixed_point64;$/;"	x
eosio::get_action	transaction.hpp	/^   inline action get_action( uint32_t type, uint32_t index ) {$/;"	f	namespace:eosio	signature:( uint32_t type, uint32_t index )
eosio::get_blockchain_parameters	eosiolib.cpp	/^   void get_blockchain_parameters(eosio::blockchain_parameters& params) {$/;"	f	namespace:eosio	signature:(eosio::blockchain_parameters& params)
eosio::get_blockchain_parameters	privileged.hpp	/^   void get_blockchain_parameters(eosio::blockchain_parameters& params);$/;"	p	namespace:eosio	signature:(eosio::blockchain_parameters& params)
eosio::has_auth	action.hpp	/^   inline bool has_auth( name n ) {$/;"	f	namespace:eosio	signature:( name n )
eosio::hours	time.hpp	/^  inline microseconds hours(int64_t h) { return minutes(60*h); }$/;"	f	namespace:eosio	signature:(int64_t h)
eosio::ignore	ignore.hpp	/^   struct [[eosio::ignore]] ignore {};$/;"	s	namespace:eosio
eosio::ignore_wrapper	ignore.hpp	/^   struct ignore_wrapper {$/;"	s	namespace:eosio
eosio::ignore_wrapper::get	ignore.hpp	/^      constexpr inline T get() { return value; }$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
eosio::ignore_wrapper::ignore_wrapper	ignore.hpp	/^      constexpr ignore_wrapper() {}$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
eosio::ignore_wrapper::ignore_wrapper	ignore.hpp	/^      constexpr ignore_wrapper(T val) : value(val) {}$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:(T val)
eosio::ignore_wrapper::ignore_wrapper	ignore.hpp	/^      constexpr ignore_wrapper(ignore<T> val) {}$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:(ignore<T> val)
eosio::ignore_wrapper::operator T	ignore.hpp	/^      constexpr operator T() { return value; }$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
eosio::ignore_wrapper::operator ignore<T>	ignore.hpp	/^      constexpr operator ignore<T>() { return {}; }$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
eosio::ignore_wrapper::value	ignore.hpp	/^      T value;$/;"	m	struct:eosio::ignore_wrapper	access:public
eosio::indexed_by	multi_index.hpp	/^struct indexed_by {$/;"	s	namespace:eosio
eosio::indexed_by::constants	multi_index.hpp	/^   enum constants { index_name   = static_cast<uint64_t>(IndexName) };$/;"	g	struct:eosio::indexed_by	access:public
eosio::indexed_by::index_name	multi_index.hpp	/^   enum constants { index_name   = static_cast<uint64_t>(IndexName) };$/;"	e	enum:eosio::indexed_by::constants
eosio::indexed_by::secondary_extractor_type	multi_index.hpp	/^   typedef Extractor secondary_extractor_type;$/;"	t	struct:eosio::indexed_by	access:public
eosio::inline_dispatcher	action.hpp	/^   struct inline_dispatcher;$/;"	x
eosio::inline_dispatcher	action.hpp	/^   struct inline_dispatcher<void(T::*)(Args...), Name> {$/;"	s	namespace:eosio
eosio::inline_dispatcher::call	action.hpp	/^      static void call(name code, const permission_level& perm, std::tuple<Args...> args) {$/;"	f	struct:eosio::inline_dispatcher	access:public	signature:(name code, const permission_level& perm, std::tuple<Args...> args)
eosio::inline_dispatcher::call	action.hpp	/^      static void call(name code, std::vector<permission_level> perms, std::tuple<Args...> args) {$/;"	f	struct:eosio::inline_dispatcher	access:public	signature:(name code, std::vector<permission_level> perms, std::tuple<Args...> args)
eosio::iostream	print.hpp	/^   class iostream {};$/;"	c	namespace:eosio
eosio::is_account	action.hpp	/^   inline bool is_account( name n ) {$/;"	f	namespace:eosio	signature:( name n )
eosio::key256	fixed_key.hpp	/^   typedef fixed_key<32> key256;$/;"	t	namespace:eosio
eosio::memory_heap	eosiolib.cpp	/^   memory_manager memory_heap;$/;"	m	namespace:eosio	file:
eosio::memory_manager	eosiolib.cpp	/^   class memory_manager  \/\/ NOTE: Should never allocate another instance of memory_manager$/;"	c	namespace:eosio	file:
eosio::memory_manager::_active_free_heap	eosiolib.cpp	/^      uint32_t _active_free_heap;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_active_heap	eosiolib.cpp	/^      uint32_t _active_heap;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_alloc_memory_mask	eosiolib.cpp	/^      static const uint32_t _alloc_memory_mask = uint32_t(1) << 31;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_available_heaps	eosiolib.cpp	/^      memory _available_heaps[_heaps_size];$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_heaps_actual_size	eosiolib.cpp	/^      uint32_t _heaps_actual_size;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_heaps_size	eosiolib.cpp	/^      static const uint32_t _heaps_size = 16;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_initial_heap	eosiolib.cpp	/^      char _initial_heap[_initial_heap_size];$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_initial_heap_size	eosiolib.cpp	/^      static const uint32_t _initial_heap_size = 8192;\/\/32768;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_mem_block	eosiolib.cpp	/^      static const uint32_t _mem_block = 8;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_rem_mem_block_mask	eosiolib.cpp	/^      static const uint32_t _rem_mem_block_mask = _mem_block - 1;$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::_size_marker	eosiolib.cpp	/^      static const uint32_t _size_marker = sizeof(uint32_t);$/;"	m	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::adjust_to_mem_block	eosiolib.cpp	/^      void adjust_to_mem_block(uint32_t& size)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(uint32_t& size)
eosio::memory_manager::calloc	eosiolib.cpp	/^   friend void* ::calloc(size_t count, size_t size);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(size_t count, size_t size)
eosio::memory_manager::free	eosiolib.cpp	/^      void free(void* ptr)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(void* ptr)
eosio::memory_manager::free	eosiolib.cpp	/^   friend void ::free(void* ptr);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(void* ptr)
eosio::memory_manager::malloc	eosiolib.cpp	/^      void* malloc(uint32_t size)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(uint32_t size)
eosio::memory_manager::malloc	eosiolib.cpp	/^   friend void* ::malloc(size_t size);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(size_t size)
eosio::memory_manager::memory	eosiolib.cpp	/^      class memory$/;"	c	class:eosio::memory_manager	file:	access:private
eosio::memory_manager::memory	eosiolib.cpp	/^      class memory;$/;"	x	file:
eosio::memory_manager::memory::_heap	eosiolib.cpp	/^         char* _heap;$/;"	m	class:eosio::memory_manager::memory	file:	access:private
eosio::memory_manager::memory::_heap_size	eosiolib.cpp	/^         uint32_t _heap_size;$/;"	m	class:eosio::memory_manager::memory	file:	access:private
eosio::memory_manager::memory::_offset	eosiolib.cpp	/^         uint32_t _offset;$/;"	m	class:eosio::memory_manager::memory	file:	access:private
eosio::memory_manager::memory::buffer_ptr	eosiolib.cpp	/^         class buffer_ptr$/;"	c	class:eosio::memory_manager::memory	file:	access:private
eosio::memory_manager::memory::buffer_ptr::_heap_end	eosiolib.cpp	/^            const char* const _heap_end;$/;"	m	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private
eosio::memory_manager::memory::buffer_ptr::_ptr	eosiolib.cpp	/^            char* _ptr;$/;"	m	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private
eosio::memory_manager::memory::buffer_ptr::_size	eosiolib.cpp	/^            uint32_t _size;$/;"	m	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private
eosio::memory_manager::memory::buffer_ptr::buffer_ptr	eosiolib.cpp	/^            buffer_ptr(void* ptr, const char* const heap_end)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(void* ptr, const char* const heap_end)
eosio::memory_manager::memory::buffer_ptr::buffer_ptr	eosiolib.cpp	/^            buffer_ptr(void* ptr, uint32_t buff_size, const char* const heap_end)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(void* ptr, uint32_t buff_size, const char* const heap_end)
eosio::memory_manager::memory::buffer_ptr::end	eosiolib.cpp	/^            char* end() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
eosio::memory_manager::memory::buffer_ptr::is_alloc	eosiolib.cpp	/^            bool is_alloc() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
eosio::memory_manager::memory::buffer_ptr::mark_alloc	eosiolib.cpp	/^            void mark_alloc()$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:()
eosio::memory_manager::memory::buffer_ptr::mark_free	eosiolib.cpp	/^            void mark_free()$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:()
eosio::memory_manager::memory::buffer_ptr::merge_contiguous	eosiolib.cpp	/^            bool merge_contiguous(uint32_t needed_size)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(uint32_t needed_size)
eosio::memory_manager::memory::buffer_ptr::merge_contiguous	eosiolib.cpp	/^            bool merge_contiguous(uint32_t needed_size, bool all_or_nothing)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private	signature:(uint32_t needed_size, bool all_or_nothing)
eosio::memory_manager::memory::buffer_ptr::merge_contiguous_if_available	eosiolib.cpp	/^            bool merge_contiguous_if_available(uint32_t needed_size)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(uint32_t needed_size)
eosio::memory_manager::memory::buffer_ptr::next_ptr	eosiolib.cpp	/^            char* next_ptr() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
eosio::memory_manager::memory::buffer_ptr::ptr	eosiolib.cpp	/^            char* ptr() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
eosio::memory_manager::memory::buffer_ptr::size	eosiolib.cpp	/^            uint32_t size() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
eosio::memory_manager::memory::buffer_ptr::size	eosiolib.cpp	/^            void size(uint32_t val)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(uint32_t val)
eosio::memory_manager::memory::cleanup_remaining	eosiolib.cpp	/^         void cleanup_remaining()$/;"	f	class:eosio::memory_manager::memory	access:public	signature:()
eosio::memory_manager::memory::expand_memory	eosiolib.cpp	/^         bool expand_memory(char* exp_mem, uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* exp_mem, uint32_t size)
eosio::memory_manager::memory::free	eosiolib.cpp	/^         void free(char* ptr)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* ptr)
eosio::memory_manager::memory::init	eosiolib.cpp	/^         void init(char* const mem_heap, uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* const mem_heap, uint32_t size)
eosio::memory_manager::memory::is_capacity_remaining	eosiolib.cpp	/^         uint32_t is_capacity_remaining() const$/;"	f	class:eosio::memory_manager::memory	access:public	signature:() const
eosio::memory_manager::memory::is_in_heap	eosiolib.cpp	/^         uint32_t is_in_heap(const char* const ptr) const$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(const char* const ptr) const
eosio::memory_manager::memory::is_init	eosiolib.cpp	/^         uint32_t is_init() const$/;"	f	class:eosio::memory_manager::memory	access:public	signature:() const
eosio::memory_manager::memory::malloc	eosiolib.cpp	/^         char* malloc(uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(uint32_t size)
eosio::memory_manager::memory::malloc_from_freed	eosiolib.cpp	/^         char* malloc_from_freed(uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(uint32_t size)
eosio::memory_manager::memory::memory	eosiolib.cpp	/^         memory()$/;"	f	class:eosio::memory_manager::memory	access:public	signature:()
eosio::memory_manager::memory::realloc_in_place	eosiolib.cpp	/^         char* realloc_in_place(char* const ptr, uint32_t size, uint32_t* orig_ptr_size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* const ptr, uint32_t size, uint32_t* orig_ptr_size)
eosio::memory_manager::memory_manager	eosiolib.cpp	/^      memory_manager()$/;"	f	class:eosio::memory_manager	access:public	signature:()
eosio::memory_manager::next_active_heap	eosiolib.cpp	/^      memory* next_active_heap()$/;"	f	class:eosio::memory_manager	file:	access:private	signature:()
eosio::memory_manager::realloc	eosiolib.cpp	/^      void* realloc(void* ptr, uint32_t size)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(void* ptr, uint32_t size)
eosio::memory_manager::realloc	eosiolib.cpp	/^   friend void* ::realloc(void* ptr, size_t size);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(void* ptr, size_t size)
eosio::microseconds	time.hpp	/^  class microseconds {$/;"	c	namespace:eosio
eosio::microseconds::_count	time.hpp	/^        int64_t _count;$/;"	m	class:eosio::microseconds	access:public
eosio::microseconds::count	time.hpp	/^        int64_t count()const { return _count; }$/;"	f	class:eosio::microseconds	access:public	signature:() const
eosio::microseconds::maximum	time.hpp	/^        static microseconds maximum() { return microseconds(0x7fffffffffffffffll); }$/;"	f	class:eosio::microseconds	access:public	signature:()
eosio::microseconds::microseconds	time.hpp	/^        explicit microseconds( int64_t c = 0) :_count(c){}$/;"	f	class:eosio::microseconds	access:public	signature:( int64_t c = 0)
eosio::microseconds::operator !=	time.hpp	/^        bool operator!=(const microseconds& c)const { return _count != c._count; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c) const
eosio::microseconds::operator +	time.hpp	/^        friend microseconds operator + (const  microseconds& l, const microseconds& r ) { return microseconds(l._count+r._count); }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& l, const microseconds& r )
eosio::microseconds::operator +=	time.hpp	/^        microseconds& operator+=(const microseconds& c) { _count += c._count; return *this; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c)
eosio::microseconds::operator -	time.hpp	/^        friend microseconds operator - (const  microseconds& l, const microseconds& r ) { return microseconds(l._count-r._count); }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& l, const microseconds& r )
eosio::microseconds::operator -=	time.hpp	/^        microseconds& operator-=(const microseconds& c) { _count -= c._count; return *this; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c)
eosio::microseconds::operator <	time.hpp	/^        friend bool operator<(const microseconds& a, const microseconds& b){ return a._count < b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
eosio::microseconds::operator <=	time.hpp	/^        friend bool operator<=(const microseconds& a, const microseconds& b){ return a._count <= b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
eosio::microseconds::operator ==	time.hpp	/^        bool operator==(const microseconds& c)const { return _count == c._count; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c) const
eosio::microseconds::operator >	time.hpp	/^        friend bool operator>(const microseconds& a, const microseconds& b){ return a._count > b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
eosio::microseconds::operator >=	time.hpp	/^        friend bool operator>=(const microseconds& a, const microseconds& b){ return a._count >= b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
eosio::microseconds::time_point	time.hpp	/^        friend class time_point;$/;"	x
eosio::microseconds::to_seconds	time.hpp	/^        int64_t to_seconds()const { return _count\/1000000; }$/;"	f	class:eosio::microseconds	access:public	signature:() const
eosio::milliseconds	time.hpp	/^  inline microseconds milliseconds( int64_t s ) { return microseconds( s * 1000 ); }$/;"	f	namespace:eosio	signature:( int64_t s )
eosio::minutes	time.hpp	/^  inline microseconds minutes(int64_t m) { return seconds(60*m); }$/;"	f	namespace:eosio	signature:(int64_t m)
eosio::multi_index	multi_index.hpp	/^class multi_index$/;"	c	namespace:eosio
eosio::multi_index::_code	multi_index.hpp	/^      name     _code;$/;"	m	class:eosio::multi_index	access:private
eosio::multi_index::_indices	multi_index.hpp	/^      indices_type _indices;$/;"	m	class:eosio::multi_index	access:private
eosio::multi_index::_items_vector	multi_index.hpp	/^      mutable std::vector<item_ptr> _items_vector;$/;"	m	class:eosio::multi_index	access:private
eosio::multi_index::_next_primary_key	multi_index.hpp	/^      mutable uint64_t _next_primary_key;$/;"	m	class:eosio::multi_index	access:private
eosio::multi_index::_scope	multi_index.hpp	/^      uint64_t _scope;$/;"	m	class:eosio::multi_index	access:private
eosio::multi_index::available_primary_key	multi_index.hpp	/^      uint64_t available_primary_key()const {$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::begin	multi_index.hpp	/^      const_iterator begin()const  { return cbegin(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::cbegin	multi_index.hpp	/^      const_iterator cbegin()const {$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::cend	multi_index.hpp	/^      const_iterator cend()const   { return const_iterator( this ); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::const_iterator	multi_index.hpp	/^      struct const_iterator : public std::iterator<std::bidirectional_iterator_tag, const T> {$/;"	s	class:eosio::multi_index	inherits:std::iterator	access:public
eosio::multi_index::const_iterator::_item	multi_index.hpp	/^            const item*        _item;$/;"	m	struct:eosio::multi_index::const_iterator	access:private
eosio::multi_index::const_iterator::_multidx	multi_index.hpp	/^            const multi_index* _multidx;$/;"	m	struct:eosio::multi_index::const_iterator	access:private
eosio::multi_index::const_iterator::const_iterator	multi_index.hpp	/^            const_iterator( const multi_index* mi, const item* i = nullptr )$/;"	f	struct:eosio::multi_index::const_iterator	access:private	signature:( const multi_index* mi, const item* i = nullptr )
eosio::multi_index::const_iterator::multi_index	multi_index.hpp	/^            friend class multi_index;$/;"	x
eosio::multi_index::const_iterator::operator !=	multi_index.hpp	/^         friend bool operator != ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
eosio::multi_index::const_iterator::operator *	multi_index.hpp	/^         const T& operator*()const { return *static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:() const
eosio::multi_index::const_iterator::operator ++	multi_index.hpp	/^         const_iterator operator++(int) {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:(int)
eosio::multi_index::const_iterator::operator ++	multi_index.hpp	/^         const_iterator& operator++() {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:()
eosio::multi_index::const_iterator::operator --	multi_index.hpp	/^         const_iterator operator--(int) {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:(int)
eosio::multi_index::const_iterator::operator --	multi_index.hpp	/^         const_iterator& operator--() {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:()
eosio::multi_index::const_iterator::operator ->	multi_index.hpp	/^         const T* operator->()const { return static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:() const
eosio::multi_index::const_iterator::operator ==	multi_index.hpp	/^         friend bool operator == ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
eosio::multi_index::const_reverse_iterator	multi_index.hpp	/^      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:eosio::multi_index	access:public
eosio::multi_index::crbegin	multi_index.hpp	/^      const_reverse_iterator crbegin()const { return std::make_reverse_iterator(cend()); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::crend	multi_index.hpp	/^      const_reverse_iterator crend()const   { return std::make_reverse_iterator(cbegin()); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::emplace	multi_index.hpp	/^      const_iterator emplace( name payer, Lambda&& constructor ) {$/;"	f	class:eosio::multi_index	access:public	signature:( name payer, Lambda&& constructor )
eosio::multi_index::end	multi_index.hpp	/^      const_iterator end()const    { return cend(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::erase	multi_index.hpp	/^      const_iterator erase( const_iterator itr ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const_iterator itr )
eosio::multi_index::erase	multi_index.hpp	/^      void erase( const T& obj ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const T& obj )
eosio::multi_index::find	multi_index.hpp	/^      const_iterator find( uint64_t primary )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary ) const
eosio::multi_index::get	multi_index.hpp	/^      const T& get( uint64_t primary, const char* error_msg = "unable to find key" )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary, const char* error_msg =  ) const
eosio::multi_index::get_code	multi_index.hpp	/^      name get_code()const      { return _code; }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::get_index	multi_index.hpp	/^      auto get_index() {$/;"	f	class:eosio::multi_index	access:public	signature:()
eosio::multi_index::get_index	multi_index.hpp	/^      auto get_index()const {$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::get_scope	multi_index.hpp	/^      uint64_t get_scope()const { return _scope; }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::index	multi_index.hpp	/^      struct index {$/;"	s	class:eosio::multi_index	access:private
eosio::multi_index::index::_multidx	multi_index.hpp	/^            typename std::conditional<IsConst, const multi_index*, multi_index*>::type _multidx;$/;"	m	struct:eosio::multi_index::index	access:private
eosio::multi_index::index::begin	multi_index.hpp	/^            const_iterator begin()const  { return cbegin(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::cbegin	multi_index.hpp	/^            const_iterator cbegin()const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::cend	multi_index.hpp	/^            const_iterator cend()const   { return const_iterator( this ); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::const_iterator	multi_index.hpp	/^            struct const_iterator : public std::iterator<std::bidirectional_iterator_tag, const T> {$/;"	s	struct:eosio::multi_index::index	inherits:std::iterator	access:public
eosio::multi_index::index::const_iterator::_idx	multi_index.hpp	/^                  const index* _idx;$/;"	m	struct:eosio::multi_index::index::const_iterator	access:private
eosio::multi_index::index::const_iterator::_item	multi_index.hpp	/^                  const item*  _item;$/;"	m	struct:eosio::multi_index::index::const_iterator	access:private
eosio::multi_index::index::const_iterator::const_iterator	multi_index.hpp	/^                  const_iterator( const index* idx, const item* i = nullptr )$/;"	f	struct:eosio::multi_index::index::const_iterator	access:private	signature:( const index* idx, const item* i = nullptr )
eosio::multi_index::index::const_iterator::const_iterator	multi_index.hpp	/^                  const_iterator():_item(nullptr){}$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:()
eosio::multi_index::index::const_iterator::index	multi_index.hpp	/^                  friend struct index;$/;"	x
eosio::multi_index::index::const_iterator::operator !=	multi_index.hpp	/^                  friend bool operator != ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
eosio::multi_index::index::const_iterator::operator *	multi_index.hpp	/^                  const T& operator*()const { return *static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:() const
eosio::multi_index::index::const_iterator::operator ++	multi_index.hpp	/^                  const_iterator operator++(int){$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:(int)
eosio::multi_index::index::const_iterator::operator ++	multi_index.hpp	/^                  const_iterator& operator++() {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:()
eosio::multi_index::index::const_iterator::operator --	multi_index.hpp	/^                  const_iterator operator--(int){$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:(int)
eosio::multi_index::index::const_iterator::operator --	multi_index.hpp	/^                  const_iterator& operator--() {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:()
eosio::multi_index::index::const_iterator::operator ->	multi_index.hpp	/^                  const T* operator->()const { return static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:() const
eosio::multi_index::index::const_iterator::operator ==	multi_index.hpp	/^                  friend bool operator == ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
eosio::multi_index::index::const_reverse_iterator	multi_index.hpp	/^            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:eosio::multi_index::index	access:public
eosio::multi_index::index::constants	multi_index.hpp	/^            enum constants {$/;"	g	struct:eosio::multi_index::index	access:public
eosio::multi_index::index::crbegin	multi_index.hpp	/^            const_reverse_iterator crbegin()const { return std::make_reverse_iterator(cend()); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::crend	multi_index.hpp	/^            const_reverse_iterator crend()const   { return std::make_reverse_iterator(cbegin()); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::end	multi_index.hpp	/^            const_iterator end()const    { return cend(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::erase	multi_index.hpp	/^            const_iterator erase( const_iterator itr ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const_iterator itr )
eosio::multi_index::index::extract_secondary_key	multi_index.hpp	/^            static auto extract_secondary_key(const T& obj) { return secondary_extractor_type()(obj); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:(const T& obj)
eosio::multi_index::index::find	multi_index.hpp	/^            const_iterator find( const secondary_key_type& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary ) const
eosio::multi_index::index::find	multi_index.hpp	/^            const_iterator find( secondary_key_type&& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary ) const
eosio::multi_index::index::get	multi_index.hpp	/^            const T& get( const secondary_key_type& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary, const char* error_msg =  ) const
eosio::multi_index::index::get	multi_index.hpp	/^            const T& get( secondary_key_type&& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary, const char* error_msg =  ) const
eosio::multi_index::index::get_code	multi_index.hpp	/^            eosio::name get_code()const  { return _multidx->get_code(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::get_scope	multi_index.hpp	/^            uint64_t    get_scope()const { return _multidx->get_scope(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::index	multi_index.hpp	/^            index( typename std::conditional<IsConst, const multi_index*, multi_index*>::type midx )$/;"	f	struct:eosio::multi_index::index	access:private	signature:( typename std::conditional<IsConst, const multi_index*, multi_index*>::type midx )
eosio::multi_index::index::index_name	multi_index.hpp	/^               index_name   = static_cast<uint64_t>(IndexName),$/;"	e	enum:eosio::multi_index::index::constants
eosio::multi_index::index::index_number	multi_index.hpp	/^               index_number = Number,$/;"	e	enum:eosio::multi_index::index::constants
eosio::multi_index::index::index_table_name	multi_index.hpp	/^               index_table_name = (static_cast<uint64_t>(TableName) & 0xFFFFFFFFFFFFFFF0ULL)$/;"	e	enum:eosio::multi_index::index::constants
eosio::multi_index::index::iterator_to	multi_index.hpp	/^            const_iterator iterator_to( const T& obj ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const T& obj )
eosio::multi_index::index::lower_bound	multi_index.hpp	/^            const_iterator lower_bound( const secondary_key_type& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary ) const
eosio::multi_index::index::lower_bound	multi_index.hpp	/^            const_iterator lower_bound( secondary_key_type&& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary ) const
eosio::multi_index::index::modify	multi_index.hpp	/^            void modify( const_iterator itr, eosio::name payer, Lambda&& updater ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const_iterator itr, eosio::name payer, Lambda&& updater )
eosio::multi_index::index::multi_index	multi_index.hpp	/^            friend class multi_index;$/;"	x
eosio::multi_index::index::name	multi_index.hpp	/^            constexpr static uint64_t name()   { return index_table_name; }$/;"	f	struct:eosio::multi_index::index	access:public	signature:()
eosio::multi_index::index::number	multi_index.hpp	/^            constexpr static uint64_t number() { return Number; }$/;"	f	struct:eosio::multi_index::index	access:public	signature:()
eosio::multi_index::index::rbegin	multi_index.hpp	/^            const_reverse_iterator rbegin()const  { return crbegin(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::rend	multi_index.hpp	/^            const_reverse_iterator rend()const    { return crend(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
eosio::multi_index::index::require_find	multi_index.hpp	/^            const_iterator require_find( const secondary_key_type& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary, const char* error_msg =  ) const
eosio::multi_index::index::require_find	multi_index.hpp	/^            const_iterator require_find( secondary_key_type&& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary, const char* error_msg =  ) const
eosio::multi_index::index::secondary_extractor_type	multi_index.hpp	/^            typedef Extractor  secondary_extractor_type;$/;"	t	struct:eosio::multi_index::index	access:public
eosio::multi_index::index::secondary_key_type	multi_index.hpp	/^            typedef typename std::decay<decltype( Extractor()(nullptr) )>::type secondary_key_type;$/;"	t	struct:eosio::multi_index::index	access:public
eosio::multi_index::index::table_name	multi_index.hpp	/^               table_name   = static_cast<uint64_t>(TableName),$/;"	e	enum:eosio::multi_index::index::constants
eosio::multi_index::index::upper_bound	multi_index.hpp	/^            const_iterator upper_bound( const secondary_key_type& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary ) const
eosio::multi_index::index::upper_bound	multi_index.hpp	/^            const_iterator upper_bound( secondary_key_type&& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary ) const
eosio::multi_index::index::validate_index_name	multi_index.hpp	/^            constexpr static bool validate_index_name( eosio::name n ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( eosio::name n )
eosio::multi_index::index::validate_index_name	multi_index.hpp	/^            static_assert( validate_index_name( name(IndexName) ), "invalid index name used in multi_index" );$/;"	p	struct:eosio::multi_index::index	access:public	signature:(name(
eosio::multi_index::indices_type	multi_index.hpp	/^      typedef decltype( multi_index::transform_indices() ) indices_type;$/;"	t	class:eosio::multi_index	access:private
eosio::multi_index::intc	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	s	class:eosio::multi_index	access:private
eosio::multi_index::intc::e	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	g	struct:eosio::multi_index::intc	access:public
eosio::multi_index::intc::operator uint64_t	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	f	struct:eosio::multi_index::intc	access:public	signature:() const
eosio::multi_index::intc::value	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	e	enum:eosio::multi_index::intc::e
eosio::multi_index::item	multi_index.hpp	/^      struct item : public T$/;"	s	class:eosio::multi_index	inherits:T	access:private
eosio::multi_index::item::__idx	multi_index.hpp	/^         const multi_index* __idx;$/;"	m	struct:eosio::multi_index::item	access:public
eosio::multi_index::item::__iters	multi_index.hpp	/^         int32_t            __iters[sizeof...(Indices)+(sizeof...(Indices)==0)];$/;"	m	struct:eosio::multi_index::item	access:public
eosio::multi_index::item::__primary_itr	multi_index.hpp	/^         int32_t            __primary_itr;$/;"	m	struct:eosio::multi_index::item	access:public
eosio::multi_index::item::item	multi_index.hpp	/^         item( const multi_index* idx, Constructor&& c )$/;"	f	struct:eosio::multi_index::item	access:public	signature:( const multi_index* idx, Constructor&& c )
eosio::multi_index::item_ptr	multi_index.hpp	/^      struct item_ptr$/;"	s	class:eosio::multi_index	access:private
eosio::multi_index::item_ptr::_item	multi_index.hpp	/^         std::unique_ptr<item> _item;$/;"	m	struct:eosio::multi_index::item_ptr	access:public
eosio::multi_index::item_ptr::_primary_itr	multi_index.hpp	/^         int32_t               _primary_itr;$/;"	m	struct:eosio::multi_index::item_ptr	access:public
eosio::multi_index::item_ptr::_primary_key	multi_index.hpp	/^         uint64_t              _primary_key;$/;"	m	struct:eosio::multi_index::item_ptr	access:public
eosio::multi_index::item_ptr::item_ptr	multi_index.hpp	/^         item_ptr(std::unique_ptr<item>&& i, uint64_t pk, int32_t pitr)$/;"	f	struct:eosio::multi_index::item_ptr	access:public	signature:(std::unique_ptr<item>&& i, uint64_t pk, int32_t pitr)
eosio::multi_index::iterator_to	multi_index.hpp	/^      const_iterator iterator_to( const T& obj )const {$/;"	f	class:eosio::multi_index	access:public	signature:( const T& obj ) const
eosio::multi_index::load_object_by_primary_iterator	multi_index.hpp	/^      const item& load_object_by_primary_iterator( int32_t itr )const {$/;"	f	class:eosio::multi_index	access:private	signature:( int32_t itr ) const
eosio::multi_index::lower_bound	multi_index.hpp	/^      const_iterator lower_bound( uint64_t primary )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary ) const
eosio::multi_index::max_stack_buffer_size	multi_index.hpp	/^      constexpr static size_t max_stack_buffer_size = 512;$/;"	m	class:eosio::multi_index	access:private
eosio::multi_index::modify	multi_index.hpp	/^      void modify( const T& obj, name payer, Lambda&& updater ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const T& obj, name payer, Lambda&& updater )
eosio::multi_index::modify	multi_index.hpp	/^      void modify( const_iterator itr, name payer, Lambda&& updater ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const_iterator itr, name payer, Lambda&& updater )
eosio::multi_index::multi_index	multi_index.hpp	/^      multi_index( name code, uint64_t scope )$/;"	f	class:eosio::multi_index	access:public	signature:( name code, uint64_t scope )
eosio::multi_index::rbegin	multi_index.hpp	/^      const_reverse_iterator rbegin()const  { return crbegin(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::rend	multi_index.hpp	/^      const_reverse_iterator rend()const    { return crend(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
eosio::multi_index::require_find	multi_index.hpp	/^      const_iterator require_find( uint64_t primary, const char* error_msg = "unable to find key" )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary, const char* error_msg =  ) const
eosio::multi_index::static_assert	multi_index.hpp	/^      static_assert( sizeof...(Indices) <= 16, "multi_index only supports a maximum of 16 secondary indices" );$/;"	p	class:eosio::multi_index	access:private	signature:( sizeof....(Indices) <= 16,  )
eosio::multi_index::transform_indices	multi_index.hpp	/^      static constexpr auto transform_indices( ) {$/;"	f	class:eosio::multi_index	access:private	signature:( )
eosio::multi_index::upper_bound	multi_index.hpp	/^      const_iterator upper_bound( uint64_t primary )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary ) const
eosio::multi_index::validate_table_name	multi_index.hpp	/^      constexpr static bool validate_table_name( name n ) {$/;"	f	class:eosio::multi_index	access:private	signature:( name n )
eosio::multi_index::validate_table_name	multi_index.hpp	/^      static_assert( validate_table_name( name(TableName) ), "multi_index does not support table names with a length greater than 12");$/;"	p	class:eosio::multi_index	access:private	signature:(name(
eosio::name	name.hpp	/^   struct name {$/;"	s	namespace:eosio
eosio::name::char_to_value	name.hpp	/^      static constexpr uint8_t char_to_value( char c ) {$/;"	f	struct:eosio::name	access:public	signature:( char c )
eosio::name::length	name.hpp	/^      constexpr uint8_t length()const {$/;"	f	struct:eosio::name	access:public	signature:() const
eosio::name::name	name.hpp	/^      constexpr explicit name( name::raw r )$/;"	f	struct:eosio::name	access:public	signature:( name::raw r )
eosio::name::name	name.hpp	/^      constexpr explicit name( std::string_view str )$/;"	f	struct:eosio::name	access:public	signature:( std::string_view str )
eosio::name::name	name.hpp	/^      constexpr explicit name( uint64_t v )$/;"	f	struct:eosio::name	access:public	signature:( uint64_t v )
eosio::name::name	name.hpp	/^      constexpr name() : value(0) {}$/;"	f	struct:eosio::name	access:public	signature:()
eosio::name::operator !=	name.hpp	/^      friend constexpr bool operator != ( const name& a, const name& b ) {$/;"	f	struct:eosio::name	access:friend	signature:( const name& a, const name& b )
eosio::name::operator <	name.hpp	/^      friend constexpr bool operator < ( const name& a, const name& b ) {$/;"	f	struct:eosio::name	access:friend	signature:( const name& a, const name& b )
eosio::name::operator ==	name.hpp	/^      friend constexpr bool operator == ( const name& a, const name& b ) {$/;"	f	struct:eosio::name	access:friend	signature:( const name& a, const name& b )
eosio::name::operator bool	name.hpp	/^      constexpr explicit operator bool()const { return value != 0; }$/;"	f	struct:eosio::name	access:public	signature:() const
eosio::name::operator raw	name.hpp	/^      constexpr operator raw()const { return raw(value); }$/;"	f	struct:eosio::name	access:public	signature:() const
eosio::name::raw	name.hpp	/^      enum class raw : uint64_t {};$/;"	c	struct:eosio::name	inherits:uint64_t	access:public
eosio::name::suffix	name.hpp	/^      constexpr name suffix()const {$/;"	f	struct:eosio::name	access:public	signature:() const
eosio::name::to_string	name.hpp	/^      std::string to_string()const {$/;"	f	struct:eosio::name	access:public	signature:() const
eosio::name::value	name.hpp	/^      uint64_t value = 0;$/;"	m	struct:eosio::name	access:public
eosio::name::write_as_string	name.hpp	/^      char* write_as_string( char* begin, char* end )const {$/;"	f	struct:eosio::name	access:public	signature:( char* begin, char* end ) const
eosio::onerror	transaction.hpp	/^   struct onerror {$/;"	s	namespace:eosio
eosio::onerror::from_current_action	transaction.hpp	/^      static onerror from_current_action() {$/;"	f	struct:eosio::onerror	access:public	signature:()
eosio::onerror::sender_id	transaction.hpp	/^      uint128_t          sender_id;$/;"	m	struct:eosio::onerror	access:public
eosio::onerror::sent_trx	transaction.hpp	/^      std::vector<char> sent_trx;$/;"	m	struct:eosio::onerror	access:public
eosio::onerror::unpack_sent_trx	transaction.hpp	/^      transaction unpack_sent_trx() const {$/;"	f	struct:eosio::onerror	access:public	signature:() const
eosio::operator !=	fixed_bytes.hpp	/^   bool operator !=(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
eosio::operator !=	fixed_key.hpp	/^   bool operator !=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator <	fixed_bytes.hpp	/^   bool operator <(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
eosio::operator <	fixed_key.hpp	/^   bool operator <(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {$/;"	f	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator <	fixed_key.hpp	/^   bool operator <(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const T (&v)[N] ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const T (&v)[N] )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const boost::container::flat_set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const boost::container::flat_set<T>& s )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::array<T,N>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::array<T,N>& v )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::map<K,V>& m )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::set<T>& s )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::string& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::string& v )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::vector<T>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::vector<T>& v )
eosio::operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::vector<char>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::vector<char>& v )
eosio::operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const T& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const T& v )
eosio::operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const boost::container::flat_map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const boost::container::flat_map<K,V>& m )
eosio::operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const std::pair<T1, T2>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::pair<T1, T2>& t )
eosio::operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const std::tuple<Args...>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::tuple<Args...>& t )
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const ::eosio::ignore<T>& val) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const ::eosio::ignore<T>& val)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const ::eosio::ignore_wrapper<T>& val) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const ::eosio::ignore_wrapper<T>& val)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const bool& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const bool& d)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_checksum160& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_checksum160& cs)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_checksum256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_checksum256& d)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_checksum512& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_checksum512& cs)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_public_key& pubkey)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::binary_extension<T>& be) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::binary_extension<T>& be)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::public_key& pubkey)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::signature& sig) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::signature& sig)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::symbol sym) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::symbol sym)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::symbol_code sym_code) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::symbol_code sym_code)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const fixed_bytes<Size>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const fixed_bytes<Size>& d)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const key256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const key256& d)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::deque<T>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::deque<T>& d)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::list<T>& l) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::list<T>& l)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::optional<T>& opt) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::optional<T>& opt)
eosio::operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::variant<Ts...>& var) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::variant<Ts...>& var)
eosio::operator <<	print.hpp	/^   inline iostream& operator<<( iostream& out, const T& v ) {$/;"	f	namespace:eosio	signature:( iostream& out, const T& v )
eosio::operator <=	fixed_bytes.hpp	/^   bool operator <=(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
eosio::operator <=	fixed_key.hpp	/^   bool operator <=(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {$/;"	f	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator <=	fixed_key.hpp	/^   bool operator <=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator ==	fixed_bytes.hpp	/^   bool operator ==(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
eosio::operator ==	fixed_key.hpp	/^   bool operator ==(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator >	fixed_bytes.hpp	/^   bool operator >(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
eosio::operator >	fixed_key.hpp	/^   bool operator >(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator >=	fixed_bytes.hpp	/^   bool operator >=(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
eosio::operator >=	fixed_key.hpp	/^   bool operator >=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
eosio::operator >=	fixed_key.hpp	/^   bool operator >=(const fixed_key<Size>& c1, const fixed_key<Size>& c2) {$/;"	f	namespace:eosio	signature:(const fixed_key<Size>& c1, const fixed_key<Size>& c2)
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, T (&v)[N] ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, T (&v)[N] )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, T ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, T )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, boost::container::flat_set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, boost::container::flat_set<T>& s )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::array<T,N>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::array<T,N>& v )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::map<K,V>& m )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::set<T>& s )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::string& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::string& v )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::vector<T>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::vector<T>& v )
eosio::operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::vector<char>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::vector<char>& v )
eosio::operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, T& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, T& v )
eosio::operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, boost::container::flat_map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, boost::container::flat_map<K,V>& m )
eosio::operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, std::pair<T1, T2>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::pair<T1, T2>& t )
eosio::operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, std::tuple<Args...>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::tuple<Args...>& t )
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, ::eosio::ignore<T>) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, ::eosio::ignore<T>)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, bool& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, bool& d)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_checksum160& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_checksum160& cs)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_checksum256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_checksum256& d)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_checksum512& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_checksum512& cs)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_public_key& pubkey)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::binary_extension<T>& be) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::binary_extension<T>& be)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::public_key& pubkey)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::signature& sig) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::signature& sig)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::symbol& sym) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::symbol& sym)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::symbol_code& sym_code) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::symbol_code& sym_code)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, fixed_bytes<Size>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, fixed_bytes<Size>& d)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, key256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, key256& d)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::deque<T>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::deque<T>& d)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::list<T>& l) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::list<T>& l)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::optional<T>& opt) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::optional<T>& opt)
eosio::operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::variant<Ts...>& var) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::variant<Ts...>& var)
eosio::pack	datastream.hpp	/^std::vector<char> pack( const T& value ) {$/;"	f	namespace:eosio	signature:( const T& value )
eosio::pack_size	datastream.hpp	/^size_t pack_size( const T& value ) {$/;"	f	namespace:eosio	signature:( const T& value )
eosio::permission_level	action.hpp	/^   struct permission_level {$/;"	s	namespace:eosio
eosio::permission_level::actor	action.hpp	/^      name    actor;$/;"	m	struct:eosio::permission_level	access:public
eosio::permission_level::operator ==	action.hpp	/^      friend constexpr bool operator == ( const permission_level& a, const permission_level& b ) {$/;"	f	struct:eosio::permission_level	access:friend	signature:( const permission_level& a, const permission_level& b )
eosio::permission_level::permission	action.hpp	/^      name    permission;$/;"	m	struct:eosio::permission_level	access:public
eosio::permission_level::permission_level	action.hpp	/^      permission_level( name a, name p ):actor(a),permission(p){}$/;"	f	struct:eosio::permission_level	access:public	signature:( name a, name p )
eosio::permission_level::permission_level	action.hpp	/^      permission_level(){}$/;"	f	struct:eosio::permission_level	access:public	signature:()
eosio::print	print.hpp	/^   inline void print( T num ) {$/;"	f	namespace:eosio	signature:( T num )
eosio::print	print.hpp	/^   inline void print( T&& t ) {$/;"	f	namespace:eosio	signature:( T&& t )
eosio::print	print.hpp	/^   inline void print( const char* ptr ) {$/;"	f	namespace:eosio	signature:( const char* ptr )
eosio::print	print.hpp	/^   inline void print( const fixed_bytes<Size>& val ) {$/;"	f	namespace:eosio	signature:( const fixed_bytes<Size>& val )
eosio::print	print.hpp	/^   inline void print( double num ) { printdf( num ); }$/;"	f	namespace:eosio	signature:( double num )
eosio::print	print.hpp	/^   inline void print( eosio::symbol_code sym_code ) {$/;"	f	namespace:eosio	signature:( eosio::symbol_code sym_code )
eosio::print	print.hpp	/^   inline void print( fixed_bytes<Size>& val ) {$/;"	f	namespace:eosio	signature:( fixed_bytes<Size>& val )
eosio::print	print.hpp	/^   inline void print( float num ) { printsf( num ); }$/;"	f	namespace:eosio	signature:( float num )
eosio::print	print.hpp	/^   inline void print( long double num ) { printqf( &num ); }$/;"	f	namespace:eosio	signature:( long double num )
eosio::print	print.hpp	/^   inline void print( name name ) {$/;"	f	namespace:eosio	signature:( name name )
eosio::print	print.hpp	/^   void print( Arg&& a, Args&&... args ) {$/;"	f	namespace:eosio	signature:( Arg&& a, Args&&... args )
eosio::print_f	print.hpp	/^   inline void print_f( const char* s ) {$/;"	f	namespace:eosio	signature:( const char* s )
eosio::print_f	print.hpp	/^   inline void print_f( const char* s, Arg val, Args... rest ) {$/;"	f	namespace:eosio	signature:( const char* s, Arg val, Args... rest )
eosio::producer_key	privileged.hpp	/^   struct producer_key {$/;"	s	namespace:eosio
eosio::producer_key::block_signing_key	privileged.hpp	/^      public_key       block_signing_key;$/;"	m	struct:eosio::producer_key	access:public
eosio::producer_key::operator <	privileged.hpp	/^      friend constexpr bool operator < ( const producer_key& a, const producer_key& b ) {$/;"	f	struct:eosio::producer_key	access:friend	signature:( const producer_key& a, const producer_key& b )
eosio::producer_key::producer_name	privileged.hpp	/^      name             producer_name;$/;"	m	struct:eosio::producer_key	access:public
eosio::producer_schedule	producer_schedule.hpp	/^   struct producer_schedule {$/;"	s	namespace:eosio
eosio::producer_schedule::producers	producer_schedule.hpp	/^      std::vector<producer_key>    producers;$/;"	m	struct:eosio::producer_schedule	access:public
eosio::producer_schedule::version	producer_schedule.hpp	/^      uint32_t                     version;$/;"	m	struct:eosio::producer_schedule	access:public
eosio::public_key	crypto.hpp	/^   struct public_key {$/;"	s	namespace:eosio
eosio::public_key::data	crypto.hpp	/^      std::array<char,33> data;$/;"	m	struct:eosio::public_key	access:public
eosio::public_key::operator !=	crypto.hpp	/^      friend bool operator != ( const public_key& a, const public_key& b ) {$/;"	f	struct:eosio::public_key	access:friend	signature:( const public_key& a, const public_key& b )
eosio::public_key::operator ==	crypto.hpp	/^      friend bool operator == ( const public_key& a, const public_key& b ) {$/;"	f	struct:eosio::public_key	access:friend	signature:( const public_key& a, const public_key& b )
eosio::public_key::type	crypto.hpp	/^      unsigned_int        type;$/;"	m	struct:eosio::public_key	access:public
eosio::recover_key	crypto.cpp	/^   eosio::public_key recover_key( const eosio::checksum256& digest, const eosio::signature& sig ) {$/;"	f	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig )
eosio::recover_key	crypto.hpp	/^   eosio::public_key recover_key( const eosio::checksum256& digest, const eosio::signature& sig );$/;"	p	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig )
eosio::require_auth	action.hpp	/^   inline void require_auth( const permission_level& level ) {$/;"	f	namespace:eosio	signature:( const permission_level& level )
eosio::require_auth	action.hpp	/^   inline void require_auth( name n ) {$/;"	f	namespace:eosio	signature:( name n )
eosio::require_recipient	action.hpp	/^   inline void require_recipient( name notify_account ){$/;"	f	namespace:eosio	signature:( name notify_account )
eosio::require_recipient	action.hpp	/^   void require_recipient( name notify_account, accounts... remaining_accounts ){$/;"	f	namespace:eosio	signature:( name notify_account, accounts... remaining_accounts )
eosio::ripemd160	crypto.cpp	/^   eosio::checksum160 ripemd160( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::ripemd160	crypto.hpp	/^   eosio::checksum160 ripemd160( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::seconds	time.hpp	/^  inline microseconds seconds( int64_t s ) { return microseconds( s * 1000000 ); }$/;"	f	namespace:eosio	signature:( int64_t s )
eosio::set_blockchain_parameters	eosiolib.cpp	/^   void set_blockchain_parameters(const eosio::blockchain_parameters& params) {$/;"	f	namespace:eosio	signature:(const eosio::blockchain_parameters& params)
eosio::set_blockchain_parameters	privileged.hpp	/^   void set_blockchain_parameters(const eosio::blockchain_parameters& params);$/;"	p	namespace:eosio	signature:(const eosio::blockchain_parameters& params)
eosio::sha1	crypto.cpp	/^   eosio::checksum160 sha1( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::sha1	crypto.hpp	/^   eosio::checksum160 sha1( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::sha256	crypto.cpp	/^   eosio::checksum256 sha256( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::sha256	crypto.hpp	/^   eosio::checksum256 sha256( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::sha512	crypto.cpp	/^   eosio::checksum512 sha512( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::sha512	crypto.hpp	/^   eosio::checksum512 sha512( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
eosio::signature	crypto.hpp	/^   struct signature {$/;"	s	namespace:eosio
eosio::signature::data	crypto.hpp	/^      std::array<char,65> data;$/;"	m	struct:eosio::signature	access:public
eosio::signature::operator !=	crypto.hpp	/^      friend bool operator != ( const signature& a, const signature& b ) {$/;"	f	struct:eosio::signature	access:friend	signature:( const signature& a, const signature& b )
eosio::signature::operator ==	crypto.hpp	/^      friend bool operator == ( const signature& a, const signature& b ) {$/;"	f	struct:eosio::signature	access:friend	signature:( const signature& a, const signature& b )
eosio::signature::type	crypto.hpp	/^      unsigned_int        type;$/;"	m	struct:eosio::signature	access:public
eosio::singleton	singleton.hpp	/^   class singleton$/;"	c	namespace:eosio
eosio::singleton::_t	singleton.hpp	/^         table _t;$/;"	m	class:eosio::singleton	access:private
eosio::singleton::exists	singleton.hpp	/^         bool exists() {$/;"	f	class:eosio::singleton	access:public	signature:()
eosio::singleton::get	singleton.hpp	/^         T get() {$/;"	f	class:eosio::singleton	access:public	signature:()
eosio::singleton::get_or_create	singleton.hpp	/^         T get_or_create( name bill_to_account, const T& def = T() ) {$/;"	f	class:eosio::singleton	access:public	signature:( name bill_to_account, const T& def = T() )
eosio::singleton::get_or_default	singleton.hpp	/^         T get_or_default( const T& def = T() ) {$/;"	f	class:eosio::singleton	access:public	signature:( const T& def = T() )
eosio::singleton::pk_value	singleton.hpp	/^      constexpr static uint64_t pk_value = static_cast<uint64_t>(SingletonName);$/;"	m	class:eosio::singleton	access:private
eosio::singleton::remove	singleton.hpp	/^         void remove( ) {$/;"	f	class:eosio::singleton	access:public	signature:( )
eosio::singleton::row	singleton.hpp	/^      struct row {$/;"	s	class:eosio::singleton	access:private
eosio::singleton::row::primary_key	singleton.hpp	/^         uint64_t primary_key() const { return pk_value; }$/;"	f	struct:eosio::singleton::row	access:public	signature:() const
eosio::singleton::row::value	singleton.hpp	/^         T value;$/;"	m	struct:eosio::singleton::row	access:public
eosio::singleton::set	singleton.hpp	/^         void set( const T& value, name bill_to_account ) {$/;"	f	class:eosio::singleton	access:public	signature:( const T& value, name bill_to_account )
eosio::singleton::singleton	singleton.hpp	/^         singleton( name code, uint64_t scope ) : _t( code, scope ) {}$/;"	f	class:eosio::singleton	access:public	signature:( name code, uint64_t scope )
eosio::singleton::table	singleton.hpp	/^      typedef eosio::multi_index<SingletonName, row> table;$/;"	t	class:eosio::singleton	access:private
eosio::symbol	symbol.hpp	/^   class symbol {$/;"	c	namespace:eosio
eosio::symbol::code	symbol.hpp	/^      constexpr symbol_code code()const              { return symbol_code{value >> 8};   }$/;"	f	class:eosio::symbol	access:public	signature:() const
eosio::symbol::is_valid	symbol.hpp	/^      constexpr bool is_valid()const                 { return code().is_valid(); }$/;"	f	class:eosio::symbol	access:public	signature:() const
eosio::symbol::operator !=	symbol.hpp	/^      friend constexpr bool operator != ( const symbol& a, const symbol& b ) {$/;"	f	class:eosio::symbol	access:friend	signature:( const symbol& a, const symbol& b )
eosio::symbol::operator <	symbol.hpp	/^      friend constexpr bool operator < ( const symbol& a, const symbol& b ) {$/;"	f	class:eosio::symbol	access:friend	signature:( const symbol& a, const symbol& b )
eosio::symbol::operator ==	symbol.hpp	/^      friend constexpr bool operator == ( const symbol& a, const symbol& b ) {$/;"	f	class:eosio::symbol	access:friend	signature:( const symbol& a, const symbol& b )
eosio::symbol::operator bool	symbol.hpp	/^      constexpr explicit operator bool()const { return value != 0; }$/;"	f	class:eosio::symbol	access:public	signature:() const
eosio::symbol::precision	symbol.hpp	/^      constexpr uint8_t precision()const             { return static_cast<uint8_t>( value & 0xFFull ); }$/;"	f	class:eosio::symbol	access:public	signature:() const
eosio::symbol::print	symbol.hpp	/^      void print( bool show_precision = true )const {$/;"	f	class:eosio::symbol	access:public	signature:( bool show_precision = true ) const
eosio::symbol::raw	symbol.hpp	/^      constexpr uint64_t raw()const                  { return value; }$/;"	f	class:eosio::symbol	access:public	signature:() const
eosio::symbol::symbol	symbol.hpp	/^      constexpr explicit symbol( uint64_t raw ) : value(raw) {}$/;"	f	class:eosio::symbol	access:public	signature:( uint64_t raw )
eosio::symbol::symbol	symbol.hpp	/^      constexpr symbol( std::string_view ss, uint8_t precision )$/;"	f	class:eosio::symbol	access:public	signature:( std::string_view ss, uint8_t precision )
eosio::symbol::symbol	symbol.hpp	/^      constexpr symbol( symbol_code sc, uint8_t precision )$/;"	f	class:eosio::symbol	access:public	signature:( symbol_code sc, uint8_t precision )
eosio::symbol::symbol	symbol.hpp	/^      constexpr symbol() : value(0) {}$/;"	f	class:eosio::symbol	access:public	signature:()
eosio::symbol::value	symbol.hpp	/^      uint64_t value = 0;$/;"	m	class:eosio::symbol	access:private
eosio::symbol_code	symbol.hpp	/^   class symbol_code {$/;"	c	namespace:eosio
eosio::symbol_code::is_valid	symbol.hpp	/^      constexpr bool is_valid()const {$/;"	f	class:eosio::symbol_code	access:public	signature:() const
eosio::symbol_code::length	symbol.hpp	/^      constexpr uint32_t length()const {$/;"	f	class:eosio::symbol_code	access:public	signature:() const
eosio::symbol_code::operator !=	symbol.hpp	/^      friend constexpr bool operator != ( const symbol_code& a, const symbol_code& b ) {$/;"	f	class:eosio::symbol_code	access:friend	signature:( const symbol_code& a, const symbol_code& b )
eosio::symbol_code::operator <	symbol.hpp	/^      friend constexpr bool operator < ( const symbol_code& a, const symbol_code& b ) {$/;"	f	class:eosio::symbol_code	access:friend	signature:( const symbol_code& a, const symbol_code& b )
eosio::symbol_code::operator ==	symbol.hpp	/^      friend constexpr bool operator == ( const symbol_code& a, const symbol_code& b ) {$/;"	f	class:eosio::symbol_code	access:friend	signature:( const symbol_code& a, const symbol_code& b )
eosio::symbol_code::operator bool	symbol.hpp	/^      constexpr explicit operator bool()const { return value != 0; }$/;"	f	class:eosio::symbol_code	access:public	signature:() const
eosio::symbol_code::raw	symbol.hpp	/^      constexpr uint64_t raw()const { return value; }$/;"	f	class:eosio::symbol_code	access:public	signature:() const
eosio::symbol_code::symbol_code	symbol.hpp	/^      constexpr explicit symbol_code( std::string_view str )$/;"	f	class:eosio::symbol_code	access:public	signature:( std::string_view str )
eosio::symbol_code::symbol_code	symbol.hpp	/^      constexpr explicit symbol_code( uint64_t raw )$/;"	f	class:eosio::symbol_code	access:public	signature:( uint64_t raw )
eosio::symbol_code::symbol_code	symbol.hpp	/^      constexpr symbol_code() : value(0) {}$/;"	f	class:eosio::symbol_code	access:public	signature:()
eosio::symbol_code::to_string	symbol.hpp	/^      std::string to_string()const {$/;"	f	class:eosio::symbol_code	access:public	signature:() const
eosio::symbol_code::value	symbol.hpp	/^      uint64_t value = 0;$/;"	m	class:eosio::symbol_code	access:private
eosio::symbol_code::write_as_string	symbol.hpp	/^      char* write_as_string( char* begin, char* end )const {$/;"	f	class:eosio::symbol_code	access:public	signature:( char* begin, char* end ) const
eosio::time_point	time.hpp	/^  class time_point {$/;"	c	namespace:eosio
eosio::time_point::elapsed	time.hpp	/^        microseconds elapsed;$/;"	m	class:eosio::time_point	access:public
eosio::time_point::operator !=	time.hpp	/^        bool   operator !=( const time_point& t )const                              { return elapsed._count !=t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
eosio::time_point::operator +	time.hpp	/^        time_point   operator + (const microseconds& m) const { return time_point(elapsed+m); }$/;"	f	class:eosio::time_point	access:public	signature:(const microseconds& m) const
eosio::time_point::operator +	time.hpp	/^        time_point   operator + (const time_point& m) const { return time_point(elapsed+m.elapsed); }$/;"	f	class:eosio::time_point	access:public	signature:(const time_point& m) const
eosio::time_point::operator +=	time.hpp	/^        time_point&  operator += ( const microseconds& m)                           { elapsed+=m; return *this;                 }$/;"	f	class:eosio::time_point	access:public	signature:( const microseconds& m)
eosio::time_point::operator -	time.hpp	/^        microseconds operator - (const time_point& m) const { return microseconds(elapsed.count() - m.elapsed.count()); }$/;"	f	class:eosio::time_point	access:public	signature:(const time_point& m) const
eosio::time_point::operator -	time.hpp	/^        time_point   operator - (const microseconds& m) const { return time_point(elapsed-m); }$/;"	f	class:eosio::time_point	access:public	signature:(const microseconds& m) const
eosio::time_point::operator -=	time.hpp	/^        time_point&  operator -= ( const microseconds& m)                           { elapsed-=m; return *this;                 }$/;"	f	class:eosio::time_point	access:public	signature:( const microseconds& m)
eosio::time_point::operator <	time.hpp	/^        bool   operator < ( const time_point& t )const                              { return elapsed._count < t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
eosio::time_point::operator <=	time.hpp	/^        bool   operator <=( const time_point& t )const                              { return elapsed._count <=t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
eosio::time_point::operator ==	time.hpp	/^        bool   operator ==( const time_point& t )const                              { return elapsed._count ==t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
eosio::time_point::operator >	time.hpp	/^        bool   operator > ( const time_point& t )const                              { return elapsed._count > t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
eosio::time_point::operator >=	time.hpp	/^        bool   operator >=( const time_point& t )const                              { return elapsed._count >=t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
eosio::time_point::sec_since_epoch	time.hpp	/^        uint32_t            sec_since_epoch()const  { return uint32_t(elapsed.count() \/ 1000000); }$/;"	f	class:eosio::time_point	access:public	signature:() const
eosio::time_point::time_point	time.hpp	/^        explicit time_point( microseconds e = microseconds() ) :elapsed(e){}$/;"	f	class:eosio::time_point	access:public	signature:( microseconds e = microseconds() )
eosio::time_point::time_since_epoch	time.hpp	/^        const microseconds& time_since_epoch()const { return elapsed; }$/;"	f	class:eosio::time_point	access:public	signature:() const
eosio::time_point_sec	time.hpp	/^  class time_point_sec$/;"	c	namespace:eosio
eosio::time_point_sec::maximum	time.hpp	/^        static time_point_sec maximum() { return time_point_sec(0xffffffff); }$/;"	f	class:eosio::time_point_sec	access:public	signature:()
eosio::time_point_sec::min	time.hpp	/^        static time_point_sec min() { return time_point_sec(0); }$/;"	f	class:eosio::time_point_sec	access:public	signature:()
eosio::time_point_sec::operator !=	time.hpp	/^        friend bool      operator != ( const time_point_sec& a, const time_point_sec& b ) { return a.utc_seconds != b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
eosio::time_point_sec::operator +	time.hpp	/^        friend time_point   operator + ( const time_point_sec& t, const microseconds& m )   { return time_point(t) + m;             }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& t, const microseconds& m )
eosio::time_point_sec::operator +	time.hpp	/^        time_point_sec   operator +( uint32_t offset )const { return time_point_sec(utc_seconds + offset); }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t offset ) const
eosio::time_point_sec::operator +=	time.hpp	/^        time_point_sec&  operator += ( microseconds m ) { utc_seconds+=m.to_seconds(); return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( microseconds m )
eosio::time_point_sec::operator +=	time.hpp	/^        time_point_sec&  operator += ( time_point_sec m ) { utc_seconds+=m.utc_seconds; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( time_point_sec m )
eosio::time_point_sec::operator +=	time.hpp	/^        time_point_sec&  operator += ( uint32_t m ) { utc_seconds+=m; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t m )
eosio::time_point_sec::operator -	time.hpp	/^        friend microseconds operator - ( const time_point& t, const time_point_sec& m ) { return time_point(t) - time_point(m); }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point& t, const time_point_sec& m )
eosio::time_point_sec::operator -	time.hpp	/^        friend microseconds operator - ( const time_point_sec& t, const time_point_sec& m ) { return time_point(t) - time_point(m); }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& t, const time_point_sec& m )
eosio::time_point_sec::operator -	time.hpp	/^        friend time_point   operator - ( const time_point_sec& t, const microseconds& m )   { return time_point(t) - m;             }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& t, const microseconds& m )
eosio::time_point_sec::operator -	time.hpp	/^        time_point_sec   operator -( uint32_t offset )const { return time_point_sec(utc_seconds - offset); }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t offset ) const
eosio::time_point_sec::operator -=	time.hpp	/^        time_point_sec&  operator -= ( microseconds m ) { utc_seconds-=m.to_seconds(); return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( microseconds m )
eosio::time_point_sec::operator -=	time.hpp	/^        time_point_sec&  operator -= ( time_point_sec m ) { utc_seconds-=m.utc_seconds; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( time_point_sec m )
eosio::time_point_sec::operator -=	time.hpp	/^        time_point_sec&  operator -= ( uint32_t m ) { utc_seconds-=m; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t m )
eosio::time_point_sec::operator <	time.hpp	/^        friend bool      operator < ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds < b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
eosio::time_point_sec::operator <=	time.hpp	/^        friend bool      operator <= ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds <= b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
eosio::time_point_sec::operator =	time.hpp	/^        time_point_sec operator = ( const eosio::time_point& t )$/;"	f	class:eosio::time_point_sec	access:public	signature:( const eosio::time_point& t )
eosio::time_point_sec::operator ==	time.hpp	/^        friend bool      operator == ( const time_point_sec& a, const time_point_sec& b ) { return a.utc_seconds == b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
eosio::time_point_sec::operator >	time.hpp	/^        friend bool      operator > ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds > b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
eosio::time_point_sec::operator >=	time.hpp	/^        friend bool      operator >= ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds >= b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
eosio::time_point_sec::operator time_point	time.hpp	/^        operator time_point()const { return time_point( eosio::seconds( utc_seconds) ); }$/;"	f	class:eosio::time_point_sec	access:public	signature:() const
eosio::time_point_sec::sec_since_epoch	time.hpp	/^        uint32_t sec_since_epoch()const { return utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:public	signature:() const
eosio::time_point_sec::time_point_sec	time.hpp	/^        explicit time_point_sec(uint32_t seconds )$/;"	f	class:eosio::time_point_sec	access:public	signature:(uint32_t seconds )
eosio::time_point_sec::time_point_sec	time.hpp	/^        time_point_sec( const time_point& t )$/;"	f	class:eosio::time_point_sec	access:public	signature:( const time_point& t )
eosio::time_point_sec::time_point_sec	time.hpp	/^        time_point_sec()$/;"	f	class:eosio::time_point_sec	access:public	signature:()
eosio::time_point_sec::utc_seconds	time.hpp	/^        uint32_t utc_seconds;$/;"	m	class:eosio::time_point_sec	access:public
eosio::transaction	transaction.hpp	/^   class transaction : public transaction_header {$/;"	c	namespace:eosio	inherits:transaction_header
eosio::transaction::actions	transaction.hpp	/^      std::vector<action>  actions;$/;"	m	class:eosio::transaction	access:public
eosio::transaction::context_free_actions	transaction.hpp	/^      std::vector<action>  context_free_actions;$/;"	m	class:eosio::transaction	access:public
eosio::transaction::send	transaction.hpp	/^      void send(const uint128_t& sender_id, name payer, bool replace_existing = false) const {$/;"	f	class:eosio::transaction	access:public	signature:(const uint128_t& sender_id, name payer, bool replace_existing = false) const
eosio::transaction::transaction	transaction.hpp	/^      transaction(time_point_sec exp = time_point_sec(now() + 60)) : transaction_header( exp ) {}$/;"	f	class:eosio::transaction	access:public	signature:(time_point_sec exp = time_point_sec(now() + 60))
eosio::transaction::transaction_extensions	transaction.hpp	/^      extensions_type      transaction_extensions;$/;"	m	class:eosio::transaction	access:public
eosio::transaction_header	transaction.hpp	/^   class transaction_header {$/;"	c	namespace:eosio
eosio::transaction_header::delay_sec	transaction.hpp	/^      unsigned_int    delay_sec = 0UL; \/\/\/ number of seconds to delay transaction, default: 0$/;"	m	class:eosio::transaction_header	access:public
eosio::transaction_header::expiration	transaction.hpp	/^      time_point_sec  expiration;$/;"	m	class:eosio::transaction_header	access:public
eosio::transaction_header::max_cpu_usage_ms	transaction.hpp	/^      uint8_t         max_cpu_usage_ms = 0UL; \/\/\/ number of CPU usage units to bill transaction for$/;"	m	class:eosio::transaction_header	access:public
eosio::transaction_header::max_net_usage_words	transaction.hpp	/^      unsigned_int    max_net_usage_words = 0UL; \/\/\/ number of 8 byte words this transaction can serialize into after compressions$/;"	m	class:eosio::transaction_header	access:public
eosio::transaction_header::ref_block_num	transaction.hpp	/^      uint16_t        ref_block_num;$/;"	m	class:eosio::transaction_header	access:public
eosio::transaction_header::ref_block_prefix	transaction.hpp	/^      uint32_t        ref_block_prefix;$/;"	m	class:eosio::transaction_header	access:public
eosio::transaction_header::transaction_header	transaction.hpp	/^      transaction_header( time_point_sec exp = time_point_sec(now() + 60) )$/;"	f	class:eosio::transaction_header	access:public	signature:( time_point_sec exp = time_point_sec(now() + 60) )
eosio::unpack	datastream.hpp	/^T unpack( const char* buffer, size_t len ) {$/;"	f	namespace:eosio	signature:( const char* buffer, size_t len )
eosio::unpack	datastream.hpp	/^T unpack( const std::vector<char>& bytes ) {$/;"	f	namespace:eosio	signature:( const std::vector<char>& bytes )
eosio::unpack_action_data	action.hpp	/^   T unpack_action_data() {$/;"	f	namespace:eosio	signature:()
eosio::variant_action_wrapper	action.hpp	/^   struct variant_action_wrapper {$/;"	s	namespace:eosio
eosio::variant_action_wrapper::action_name	action.hpp	/^      static constexpr eosio::name action_name = eosio::name(Name);$/;"	m	struct:eosio::variant_action_wrapper	access:public
eosio::variant_action_wrapper::code_name	action.hpp	/^      eosio::name code_name;$/;"	m	struct:eosio::variant_action_wrapper	access:public
eosio::variant_action_wrapper::get_mem_ptr	action.hpp	/^      static constexpr auto get_mem_ptr() {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:()
eosio::variant_action_wrapper::permissions	action.hpp	/^      std::vector<eosio::permission_level> permissions;$/;"	m	struct:eosio::variant_action_wrapper	access:public
eosio::variant_action_wrapper::send	action.hpp	/^      void send(Args&&... args)const {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Args&&.... args) const
eosio::variant_action_wrapper::send_context_free	action.hpp	/^      void send_context_free(Args&&... args) const {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Args&&.... args) const
eosio::variant_action_wrapper::to_action	action.hpp	/^      action to_action(Args&&... args)const {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Args&&.... args) const
eosio::variant_action_wrapper::variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, const eosio::permission_level& perm)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, const eosio::permission_level& perm)
eosio::variant_action_wrapper::variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, const std::vector<eosio::permission_level>& perms)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, const std::vector<eosio::permission_level>& perms)
eosio::variant_action_wrapper::variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, eosio::permission_level&& perm)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, eosio::permission_level&& perm)
eosio::variant_action_wrapper::variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, std::vector<eosio::permission_level>&& perms)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, std::vector<eosio::permission_level>&& perms)
eosio_assert	system.h	/^   void  eosio_assert( uint32_t test, const char* msg );$/;"	p	signature:( uint32_t test, const char* msg )
eosio_assert_code	system.h	/^   void  eosio_assert_code( uint32_t test, uint64_t code );$/;"	p	signature:( uint32_t test, uint64_t code )
eosio_assert_message	system.h	/^   void  eosio_assert_message( uint32_t test, const char* msg, uint32_t msg_len );$/;"	p	signature:( uint32_t test, const char* msg, uint32_t msg_len )
eosio_exit	system.h	/^   void  eosio_exit( int32_t code );$/;"	p	signature:( int32_t code )
erase	multi_index.hpp	/^            const_iterator erase( const_iterator itr ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const_iterator itr )
erase	multi_index.hpp	/^      const_iterator erase( const_iterator itr ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const_iterator itr )
erase	multi_index.hpp	/^      void erase( const T& obj ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const T& obj )
execute_action	dispatcher.hpp	/^   bool execute_action( name self, name code, void (T::*func)(Args...)  ) {$/;"	f	namespace:eosio	signature:( name self, name code, void (T::*func)(Args...) )
exists	singleton.hpp	/^         bool exists() {$/;"	f	class:eosio::singleton	access:public	signature:()
expand_memory	eosiolib.cpp	/^         bool expand_memory(char* exp_mem, uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* exp_mem, uint32_t size)
expiration	transaction.h	/^   uint32_t expiration();$/;"	p	signature:()
expiration	transaction.hpp	/^      time_point_sec  expiration;$/;"	m	class:eosio::transaction_header	access:public
extended_asset	asset.hpp	/^      extended_asset( asset a, name c ):quantity(a),contract(c){}$/;"	f	struct:eosio::extended_asset	access:public	signature:( asset a, name c )
extended_asset	asset.hpp	/^      extended_asset( int64_t v, extended_symbol s ):quantity(v,s.get_symbol()),contract(s.get_contract()){}$/;"	f	struct:eosio::extended_asset	access:public	signature:( int64_t v, extended_symbol s )
extended_asset	asset.hpp	/^      extended_asset() = default;$/;"	p	struct:eosio::extended_asset	access:public	signature:()
extended_asset	asset.hpp	/^   struct extended_asset {$/;"	s	namespace:eosio
extended_symbol	symbol.hpp	/^      constexpr extended_symbol( symbol sym, name con ) : symbol(sym), contract(con) {}$/;"	f	class:eosio::extended_symbol	access:public	signature:( symbol sym, name con )
extended_symbol	symbol.hpp	/^      constexpr extended_symbol() {}$/;"	f	class:eosio::extended_symbol	access:public	signature:()
extended_symbol	symbol.hpp	/^   class extended_symbol$/;"	c	namespace:eosio
extension	transaction.hpp	/^   typedef std::tuple<uint16_t, std::vector<char>> extension;$/;"	t	namespace:eosio
extensions_type	transaction.hpp	/^   typedef std::vector<extension> extensions_type;$/;"	t	namespace:eosio
extract_secondary_key	multi_index.hpp	/^            static auto extract_secondary_key(const T& obj) { return secondary_extractor_type()(obj); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:(const T& obj)
find	multi_index.hpp	/^            const_iterator find( const secondary_key_type& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary ) const
find	multi_index.hpp	/^            const_iterator find( secondary_key_type&& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary ) const
find	multi_index.hpp	/^      const_iterator find( uint64_t primary )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary ) const
fixed_bytes	fixed_bytes.hpp	/^         constexpr fixed_bytes() : _data() {}$/;"	f	class:eosio::fixed_bytes	access:public	signature:()
fixed_bytes	fixed_bytes.hpp	/^         fixed_bytes(const std::array<word_t, num_words()>& arr)$/;"	f	class:eosio::fixed_bytes	access:public	signature:(const std::array<word_t, num_words()>& arr)
fixed_bytes	fixed_bytes.hpp	/^   class fixed_bytes {$/;"	c	namespace:eosio
fixed_bytes	fixed_bytes.hpp	/^   class fixed_bytes;$/;"	x
fixed_key	fixed_key.hpp	/^         constexpr fixed_key() : _data() {}$/;"	f	class:eosio::fixed_key	access:public	signature:()
fixed_key	fixed_key.hpp	/^         fixed_key(const std::array<word_t, num_words()>& arr)$/;"	f	class:eosio::fixed_key	access:public	signature:(const std::array<word_t, num_words()>& arr)
fixed_key	fixed_key.hpp	/^   class [[deprecated("Replaced by fixed_bytes")]] fixed_key {$/;"	c	namespace:eosio
fixed_key	fixed_key.hpp	/^   class fixed_key;$/;"	x
fixed_point128	fixedpoint.hpp	/^    struct fixed_point128$/;"	s	namespace:eosio
fixed_point128	fixedpoint.hpp	/^    template <uint8_t Q> struct fixed_point128;$/;"	x
fixed_point32	fixedpoint.hpp	/^    template <uint8_t Q> struct fixed_point32;$/;"	x
fixed_point64	fixedpoint.hpp	/^    template <uint8_t Q> struct fixed_point64;$/;"	x
free	eosiolib.cpp	/^         void free(char* ptr)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* ptr)
free	eosiolib.cpp	/^      void free(void* ptr)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(void* ptr)
free	eosiolib.cpp	/^   friend void ::free(void* ptr);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(void* ptr)
free	eosiolib.cpp	/^void free(void* ptr)$/;"	f	signature:(void* ptr)
free	memory.hpp	/^void free(void* ptr);$/;"	p	signature:(void* ptr)
from_current_action	transaction.hpp	/^      static onerror from_current_action() {$/;"	f	struct:eosio::onerror	access:public	signature:()
get	datastream.hpp	/^      inline bool get( char& c )$/;"	f	class:eosio::datastream	access:public	signature:( char& c )
get	datastream.hpp	/^      inline bool get( unsigned char& c ) { return get( *(char*)&c ); }$/;"	f	class:eosio::datastream	access:public	signature:( unsigned char& c )
get	ignore.hpp	/^      constexpr inline T get() { return value; }$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
get	multi_index.hpp	/^            const T& get( const secondary_key_type& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary, const char* error_msg =  ) const
get	multi_index.hpp	/^            const T& get( secondary_key_type&& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary, const char* error_msg =  ) const
get	multi_index.hpp	/^      const T& get( uint64_t primary, const char* error_msg = "unable to find key" )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary, const char* error_msg =  ) const
get	singleton.hpp	/^         T get() {$/;"	f	class:eosio::singleton	access:public	signature:()
get_account_creation_time	permission.h	/^   int64_t get_account_creation_time( capi_name account );$/;"	p	signature:( capi_name account )
get_action	transaction.h	/^   int get_action( uint32_t type, uint32_t index, char* buff, size_t size );$/;"	p	signature:( uint32_t type, uint32_t index, char* buff, size_t size )
get_action	transaction.hpp	/^   inline action get_action( uint32_t type, uint32_t index ) {$/;"	f	namespace:eosio	signature:( uint32_t type, uint32_t index )
get_active_producers	chain.h	/^    uint32_t get_active_producers( capi_name* producers, uint32_t datalen );$/;"	p	signature:( capi_name* producers, uint32_t datalen )
get_blockchain_parameters	eosiolib.cpp	/^   void get_blockchain_parameters(eosio::blockchain_parameters& params) {$/;"	f	namespace:eosio	signature:(eosio::blockchain_parameters& params)
get_blockchain_parameters	privileged.hpp	/^   void get_blockchain_parameters(eosio::blockchain_parameters& params);$/;"	p	namespace:eosio	signature:(eosio::blockchain_parameters& params)
get_blockchain_parameters_packed	privileged.h	/^   uint32_t get_blockchain_parameters_packed( char* data, uint32_t datalen );$/;"	p	signature:( char* data, uint32_t datalen )
get_code	contract.hpp	/^      inline name get_code()const { return _code; }$/;"	f	class:eosio::contract	access:public	signature:() const
get_code	multi_index.hpp	/^            eosio::name get_code()const  { return _multidx->get_code(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
get_code	multi_index.hpp	/^      name get_code()const      { return _code; }$/;"	f	class:eosio::multi_index	access:public	signature:() const
get_context_free_data	transaction.h	/^   int get_context_free_data( uint32_t index, char* buff, size_t size );$/;"	p	signature:( uint32_t index, char* buff, size_t size )
get_contract	symbol.hpp	/^      constexpr name  get_contract() const { return contract; }$/;"	f	class:eosio::extended_symbol	access:public	signature:() const
get_datastream	contract.hpp	/^      inline datastream<const char*> get_datastream()const { return _ds; }$/;"	f	class:eosio::contract	access:public	signature:() const
get_extended_symbol	asset.hpp	/^      extended_symbol get_extended_symbol()const { return extended_symbol{ quantity.symbol, contract }; }$/;"	f	struct:eosio::extended_asset	access:public	signature:() const
get_index	multi_index.hpp	/^      auto get_index() {$/;"	f	class:eosio::multi_index	access:public	signature:()
get_index	multi_index.hpp	/^      auto get_index()const {$/;"	f	class:eosio::multi_index	access:public	signature:() const
get_mem_ptr	action.hpp	/^      static constexpr auto get_mem_ptr() {$/;"	f	struct:eosio::action_wrapper	access:public	signature:()
get_mem_ptr	action.hpp	/^      static constexpr auto get_mem_ptr() {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:()
get_nth	action.hpp	/^      struct get_nth { static constexpr auto value  = get_nth_impl<N,0,Args...>::value; };$/;"	s	namespace:eosio::detail
get_nth_impl	action.hpp	/^      struct get_nth_impl { static constexpr auto value  = get_nth_impl<N,I+1,Args...>::value; };$/;"	s	namespace:eosio::detail
get_nth_impl	action.hpp	/^      struct get_nth_impl<N, N, Arg, Args...> { static constexpr auto value = Arg; };$/;"	s	namespace:eosio::detail
get_or_create	singleton.hpp	/^         T get_or_create( name bill_to_account, const T& def = T() ) {$/;"	f	class:eosio::singleton	access:public	signature:( name bill_to_account, const T& def = T() )
get_or_default	singleton.hpp	/^         T get_or_default( const T& def = T() ) {$/;"	f	class:eosio::singleton	access:public	signature:( const T& def = T() )
get_permission_last_used	permission.h	/^   int64_t get_permission_last_used( capi_name account, capi_name permission );$/;"	p	signature:( capi_name account, capi_name permission )
get_resource_limits	privileged.h	/^   void get_resource_limits( capi_name account, int64_t* ram_bytes, int64_t* net_weight, int64_t* cpu_weight );$/;"	p	signature:( capi_name account, int64_t* ram_bytes, int64_t* net_weight, int64_t* cpu_weight )
get_scope	multi_index.hpp	/^            uint64_t    get_scope()const { return _multidx->get_scope(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
get_scope	multi_index.hpp	/^      uint64_t get_scope()const { return _scope; }$/;"	f	class:eosio::multi_index	access:public	signature:() const
get_self	contract.hpp	/^      inline name get_self()const { return _self; }$/;"	f	class:eosio::contract	access:public	signature:() const
get_symbol	symbol.hpp	/^      constexpr symbol get_symbol() const { return symbol; }$/;"	f	class:eosio::extended_symbol	access:public	signature:() const
hana	multi_index.hpp	/^   namespace hana = boost::hana;$/;"	x
has_auth	action.h	/^   bool has_auth( capi_name name );$/;"	p	signature:( capi_name name )
has_auth	action.hpp	/^   inline bool has_auth( name n ) {$/;"	f	namespace:eosio	signature:( name n )
has_value	binary_extension.hpp	/^         constexpr bool has_value()const { return _has_value; }$/;"	f	class:eosio::binary_extension	access:public	signature:() const
hours	time.hpp	/^  inline microseconds hours(int64_t h) { return minutes(60*h); }$/;"	f	namespace:eosio	signature:(int64_t h)
ignore	ignore.hpp	/^   struct [[eosio::ignore]] ignore {};$/;"	s	namespace:eosio
ignore_wrapper	ignore.hpp	/^      constexpr ignore_wrapper() {}$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
ignore_wrapper	ignore.hpp	/^      constexpr ignore_wrapper(T val) : value(val) {}$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:(T val)
ignore_wrapper	ignore.hpp	/^      constexpr ignore_wrapper(ignore<T> val) {}$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:(ignore<T> val)
ignore_wrapper	ignore.hpp	/^   struct ignore_wrapper {$/;"	s	namespace:eosio
index	multi_index.hpp	/^                  friend struct index;$/;"	x
index	multi_index.hpp	/^            index( typename std::conditional<IsConst, const multi_index*, multi_index*>::type midx )$/;"	f	struct:eosio::multi_index::index	access:private	signature:( typename std::conditional<IsConst, const multi_index*, multi_index*>::type midx )
index	multi_index.hpp	/^      struct index {$/;"	s	class:eosio::multi_index	access:private
index_name	multi_index.hpp	/^               index_name   = static_cast<uint64_t>(IndexName),$/;"	e	enum:eosio::multi_index::index::constants
index_name	multi_index.hpp	/^   enum constants { index_name   = static_cast<uint64_t>(IndexName) };$/;"	e	enum:eosio::indexed_by::constants
index_number	multi_index.hpp	/^               index_number = Number,$/;"	e	enum:eosio::multi_index::index::constants
index_table_name	multi_index.hpp	/^               index_table_name = (static_cast<uint64_t>(TableName) & 0xFFFFFFFFFFFFFFF0ULL)$/;"	e	enum:eosio::multi_index::index::constants
indexed_by	multi_index.hpp	/^struct indexed_by {$/;"	s	namespace:eosio
indices_type	multi_index.hpp	/^      typedef decltype( multi_index::transform_indices() ) indices_type;$/;"	t	class:eosio::multi_index	access:private
init	eosiolib.cpp	/^         void init(char* const mem_heap, uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* const mem_heap, uint32_t size)
inline_dispatcher	action.hpp	/^   struct inline_dispatcher;$/;"	x
inline_dispatcher	action.hpp	/^   struct inline_dispatcher<void(T::*)(Args...), Name> {$/;"	s	namespace:eosio
intc	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	s	class:eosio::multi_index	access:private
iostream	print.hpp	/^   class iostream {};$/;"	c	namespace:eosio
is_account	action.h	/^   bool is_account( capi_name name );$/;"	p	signature:( capi_name name )
is_account	action.hpp	/^   inline bool is_account( name n ) {$/;"	f	namespace:eosio	signature:( name n )
is_alloc	eosiolib.cpp	/^            bool is_alloc() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
is_amount_within_range	asset.hpp	/^      bool is_amount_within_range()const { return -max_amount <= amount && amount <= max_amount; }$/;"	f	struct:eosio::asset	access:public	signature:() const
is_capacity_remaining	eosiolib.cpp	/^         uint32_t is_capacity_remaining() const$/;"	f	class:eosio::memory_manager::memory	access:public	signature:() const
is_in_heap	eosiolib.cpp	/^         uint32_t is_in_heap(const char* const ptr) const$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(const char* const ptr) const
is_init	eosiolib.cpp	/^         uint32_t is_init() const$/;"	f	class:eosio::memory_manager::memory	access:public	signature:() const
is_pointer	datastream.hpp	/^   constexpr bool is_pointer() {$/;"	f	namespace:eosio::_datastream_detail	signature:()
is_primitive	datastream.hpp	/^   constexpr bool is_primitive() {$/;"	f	namespace:eosio::_datastream_detail	signature:()
is_privileged	privileged.h	/^   bool is_privileged( capi_name account );$/;"	p	signature:( capi_name account )
is_same	action.hpp	/^      struct is_same { static constexpr bool value = std::is_convertible<T,U>::value; };$/;"	s	namespace:eosio::detail
is_same	action.hpp	/^      struct is_same<T,bool> { static constexpr bool value = std::is_integral<T>::value; };$/;"	s	namespace:eosio::detail
is_same	action.hpp	/^      struct is_same<bool,U> { static constexpr bool value = std::is_integral<U>::value; };$/;"	s	namespace:eosio::detail
is_valid	asset.hpp	/^      bool is_valid()const               { return is_amount_within_range() && symbol.is_valid(); }$/;"	f	struct:eosio::asset	access:public	signature:() const
is_valid	symbol.hpp	/^      constexpr bool is_valid()const                 { return code().is_valid(); }$/;"	f	class:eosio::symbol	access:public	signature:() const
is_valid	symbol.hpp	/^      constexpr bool is_valid()const {$/;"	f	class:eosio::symbol_code	access:public	signature:() const
item	multi_index.hpp	/^         item( const multi_index* idx, Constructor&& c )$/;"	f	struct:eosio::multi_index::item	access:public	signature:( const multi_index* idx, Constructor&& c )
item	multi_index.hpp	/^      struct item : public T$/;"	s	class:eosio::multi_index	inherits:T	access:private
item_ptr	multi_index.hpp	/^         item_ptr(std::unique_ptr<item>&& i, uint64_t pk, int32_t pitr)$/;"	f	struct:eosio::multi_index::item_ptr	access:public	signature:(std::unique_ptr<item>&& i, uint64_t pk, int32_t pitr)
item_ptr	multi_index.hpp	/^      struct item_ptr$/;"	s	class:eosio::multi_index	access:private
iterator_to	multi_index.hpp	/^            const_iterator iterator_to( const T& obj ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const T& obj )
iterator_to	multi_index.hpp	/^      const_iterator iterator_to( const T& obj )const {$/;"	f	class:eosio::multi_index	access:public	signature:( const T& obj ) const
key256	fixed_key.hpp	/^   typedef fixed_key<32> key256;$/;"	t	namespace:eosio
length	name.hpp	/^      constexpr uint8_t length()const {$/;"	f	struct:eosio::name	access:public	signature:() const
length	symbol.hpp	/^      constexpr uint32_t length()const {$/;"	f	class:eosio::symbol_code	access:public	signature:() const
load_object_by_primary_iterator	multi_index.hpp	/^      const item& load_object_by_primary_iterator( int32_t itr )const {$/;"	f	class:eosio::multi_index	access:private	signature:( int32_t itr ) const
lower_bound	multi_index.hpp	/^            const_iterator lower_bound( const secondary_key_type& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary ) const
lower_bound	multi_index.hpp	/^            const_iterator lower_bound( secondary_key_type&& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary ) const
lower_bound	multi_index.hpp	/^      const_iterator lower_bound( uint64_t primary )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary ) const
malloc	eosiolib.cpp	/^         char* malloc(uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(uint32_t size)
malloc	eosiolib.cpp	/^      void* malloc(uint32_t size)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(uint32_t size)
malloc	eosiolib.cpp	/^   friend void* ::malloc(size_t size);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(size_t size)
malloc	eosiolib.cpp	/^void* malloc(size_t size)$/;"	f	signature:(size_t size)
malloc	memory.hpp	/^void* malloc(size_t size);$/;"	p	signature:(size_t size)
malloc_from_freed	eosiolib.cpp	/^         char* malloc_from_freed(uint32_t size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(uint32_t size)
mark_alloc	eosiolib.cpp	/^            void mark_alloc()$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:()
mark_free	eosiolib.cpp	/^            void mark_free()$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:()
max_amount	asset.hpp	/^      static constexpr int64_t max_amount    = (1LL << 62) - 1;$/;"	m	struct:eosio::asset	access:public
max_authority_depth	privileged.hpp	/^      uint16_t max_authority_depth;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_block_cpu_usage	privileged.hpp	/^      uint32_t max_block_cpu_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_block_net_usage	privileged.hpp	/^      uint64_t max_block_net_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_cpu_usage_ms	transaction.hpp	/^      uint8_t         max_cpu_usage_ms = 0UL; \/\/\/ number of CPU usage units to bill transaction for$/;"	m	class:eosio::transaction_header	access:public
max_inline_action_depth	privileged.hpp	/^      uint16_t max_inline_action_depth;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_inline_action_size	privileged.hpp	/^      uint32_t max_inline_action_size;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_net_usage_words	transaction.hpp	/^      unsigned_int    max_net_usage_words = 0UL; \/\/\/ number of 8 byte words this transaction can serialize into after compressions$/;"	m	class:eosio::transaction_header	access:public
max_stack_buffer_size	multi_index.hpp	/^      constexpr static size_t max_stack_buffer_size = 512;$/;"	m	class:eosio::multi_index	access:private
max_transaction_cpu_usage	privileged.hpp	/^      uint32_t max_transaction_cpu_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_transaction_delay	privileged.hpp	/^      uint32_t max_transaction_delay;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_transaction_lifetime	privileged.hpp	/^      uint32_t max_transaction_lifetime;$/;"	m	struct:eosio::blockchain_parameters	access:public
max_transaction_net_usage	privileged.hpp	/^      uint32_t max_transaction_net_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
maximum	time.hpp	/^         static block_timestamp maximum() { return block_timestamp( 0xffff ); }$/;"	f	class:eosio::block_timestamp	access:public	signature:()
maximum	time.hpp	/^        static microseconds maximum() { return microseconds(0x7fffffffffffffffll); }$/;"	f	class:eosio::microseconds	access:public	signature:()
maximum	time.hpp	/^        static time_point_sec maximum() { return time_point_sec(0xffffffff); }$/;"	f	class:eosio::time_point_sec	access:public	signature:()
memory	eosiolib.cpp	/^         memory()$/;"	f	class:eosio::memory_manager::memory	access:public	signature:()
memory	eosiolib.cpp	/^      class memory$/;"	c	class:eosio::memory_manager	file:	access:private
memory	eosiolib.cpp	/^      class memory;$/;"	x	file:
memory_heap	eosiolib.cpp	/^   memory_manager memory_heap;$/;"	m	namespace:eosio	file:
memory_manager	eosiolib.cpp	/^      memory_manager()$/;"	f	class:eosio::memory_manager	access:public	signature:()
memory_manager	eosiolib.cpp	/^   class memory_manager  \/\/ NOTE: Should never allocate another instance of memory_manager$/;"	c	namespace:eosio	file:
merge_contiguous	eosiolib.cpp	/^            bool merge_contiguous(uint32_t needed_size)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(uint32_t needed_size)
merge_contiguous	eosiolib.cpp	/^            bool merge_contiguous(uint32_t needed_size, bool all_or_nothing)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	file:	access:private	signature:(uint32_t needed_size, bool all_or_nothing)
merge_contiguous_if_available	eosiolib.cpp	/^            bool merge_contiguous_if_available(uint32_t needed_size)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(uint32_t needed_size)
microseconds	time.hpp	/^        explicit microseconds( int64_t c = 0) :_count(c){}$/;"	f	class:eosio::microseconds	access:public	signature:( int64_t c = 0)
microseconds	time.hpp	/^  class microseconds {$/;"	c	namespace:eosio
milliseconds	time.hpp	/^  inline microseconds milliseconds( int64_t s ) { return microseconds( s * 1000 ); }$/;"	f	namespace:eosio	signature:( int64_t s )
min	time.hpp	/^         static block_timestamp min() { return block_timestamp(0); }$/;"	f	class:eosio::block_timestamp	access:public	signature:()
min	time.hpp	/^        static time_point_sec min() { return time_point_sec(0); }$/;"	f	class:eosio::time_point_sec	access:public	signature:()
min_transaction_cpu_usage	privileged.hpp	/^      uint32_t min_transaction_cpu_usage;$/;"	m	struct:eosio::blockchain_parameters	access:public
minutes	time.hpp	/^  inline microseconds minutes(int64_t m) { return seconds(60*m); }$/;"	f	namespace:eosio	signature:(int64_t m)
modify	multi_index.hpp	/^            void modify( const_iterator itr, eosio::name payer, Lambda&& updater ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const_iterator itr, eosio::name payer, Lambda&& updater )
modify	multi_index.hpp	/^      void modify( const T& obj, name payer, Lambda&& updater ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const T& obj, name payer, Lambda&& updater )
modify	multi_index.hpp	/^      void modify( const_iterator itr, name payer, Lambda&& updater ) {$/;"	f	class:eosio::multi_index	access:public	signature:( const_iterator itr, name payer, Lambda&& updater )
multi_index	multi_index.hpp	/^            friend class multi_index;$/;"	x
multi_index	multi_index.hpp	/^      multi_index( name code, uint64_t scope )$/;"	f	class:eosio::multi_index	access:public	signature:( name code, uint64_t scope )
multi_index	multi_index.hpp	/^class multi_index$/;"	c	namespace:eosio
name	action.hpp	/^      name                       name;$/;"	m	struct:eosio::action	access:public
name	multi_index.hpp	/^            constexpr static uint64_t name()   { return index_table_name; }$/;"	f	struct:eosio::multi_index::index	access:public	signature:()
name	name.hpp	/^      constexpr explicit name( name::raw r )$/;"	f	struct:eosio::name	access:public	signature:( name::raw r )
name	name.hpp	/^      constexpr explicit name( std::string_view str )$/;"	f	struct:eosio::name	access:public	signature:( std::string_view str )
name	name.hpp	/^      constexpr explicit name( uint64_t v )$/;"	f	struct:eosio::name	access:public	signature:( uint64_t v )
name	name.hpp	/^      constexpr name() : value(0) {}$/;"	f	struct:eosio::name	access:public	signature:()
name	name.hpp	/^   struct name {$/;"	s	namespace:eosio
net_usage_leeway	privileged.hpp	/^      uint32_t net_usage_leeway;$/;"	m	struct:eosio::blockchain_parameters	access:public
next	time.hpp	/^         block_timestamp next() const {$/;"	f	class:eosio::block_timestamp	access:public	signature:() const
next_active_heap	eosiolib.cpp	/^      memory* next_active_heap()$/;"	f	class:eosio::memory_manager	file:	access:private	signature:()
next_ptr	eosiolib.cpp	/^            char* next_ptr() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
now	system.h	/^   inline uint32_t  now() {$/;"	f	signature:()
num_words	fixed_bytes.hpp	/^         static constexpr size_t num_words() { return (Size + sizeof(word_t) - 1) \/ sizeof(word_t); }$/;"	f	class:eosio::fixed_bytes	access:public	signature:()
num_words	fixed_key.hpp	/^         static constexpr size_t num_words() { return (Size + sizeof(word_t) - 1) \/ sizeof(word_t); }$/;"	f	class:eosio::fixed_key	access:public	signature:()
number	multi_index.hpp	/^            constexpr static uint64_t number() { return Number; }$/;"	f	struct:eosio::multi_index::index	access:public	signature:()
onerror	transaction.hpp	/^   struct onerror {$/;"	s	namespace:eosio
operator !=	asset.hpp	/^      friend bool operator!=( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator !=	asset.hpp	/^      friend bool operator!=( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator !=	crypto.hpp	/^      friend bool operator != ( const public_key& a, const public_key& b ) {$/;"	f	struct:eosio::public_key	access:friend	signature:( const public_key& a, const public_key& b )
operator !=	crypto.hpp	/^      friend bool operator != ( const signature& a, const signature& b ) {$/;"	f	struct:eosio::signature	access:friend	signature:( const signature& a, const signature& b )
operator !=	fixed_bytes.hpp	/^   bool operator !=(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
operator !=	fixed_key.hpp	/^   bool operator !=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator !=	multi_index.hpp	/^                  friend bool operator != ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
operator !=	multi_index.hpp	/^         friend bool operator != ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
operator !=	name.hpp	/^      friend constexpr bool operator != ( const name& a, const name& b ) {$/;"	f	struct:eosio::name	access:friend	signature:( const name& a, const name& b )
operator !=	symbol.hpp	/^      friend constexpr bool operator != ( const extended_symbol& a, const extended_symbol& b ) {$/;"	f	class:eosio::extended_symbol	access:friend	signature:( const extended_symbol& a, const extended_symbol& b )
operator !=	symbol.hpp	/^      friend constexpr bool operator != ( const symbol& a, const symbol& b ) {$/;"	f	class:eosio::symbol	access:friend	signature:( const symbol& a, const symbol& b )
operator !=	symbol.hpp	/^      friend constexpr bool operator != ( const symbol_code& a, const symbol_code& b ) {$/;"	f	class:eosio::symbol_code	access:friend	signature:( const symbol_code& a, const symbol_code& b )
operator !=	time.hpp	/^         bool   operator !=( const block_timestamp& t )const   { return slot != t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
operator !=	time.hpp	/^        bool   operator !=( const time_point& t )const                              { return elapsed._count !=t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
operator !=	time.hpp	/^        bool operator!=(const microseconds& c)const { return _count != c._count; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c) const
operator !=	time.hpp	/^        friend bool      operator != ( const time_point_sec& a, const time_point_sec& b ) { return a.utc_seconds != b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
operator !=	varint.hpp	/^    friend bool operator!=( const int32_t& i, const signed_int& v )    { return i       != v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
operator !=	varint.hpp	/^    friend bool operator!=( const signed_int& i, const int32_t& v )    { return i.value != v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
operator !=	varint.hpp	/^    friend bool operator!=( const signed_int& i, const signed_int& v ) { return i.value != v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
operator !=	varint.hpp	/^    friend bool operator!=( const uint32_t& i, const unsigned_int& v )     { return i       != v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
operator !=	varint.hpp	/^    friend bool operator!=( const unsigned_int& i, const uint32_t& v )     { return i.value != v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
operator !=	varint.hpp	/^    friend bool operator!=( const unsigned_int& i, const unsigned_int& v ) { return i.value != v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
operator ()	multi_index.hpp	/^  Type operator()(const Class& x)const$/;"	f	struct:eosio::const_mem_fun	access:public	signature:(const Class& x) const
operator ()	multi_index.hpp	/^  Type operator()(const std::reference_wrapper<Class>& x)const$/;"	f	struct:eosio::const_mem_fun	access:public	signature:(const std::reference_wrapper<Class>& x) const
operator ()	multi_index.hpp	/^  Type operator()(const std::reference_wrapper<const Class>& x)const$/;"	f	struct:eosio::const_mem_fun	access:public	signature:(const std::reference_wrapper<const Class>& x) const
operator *	asset.hpp	/^      friend asset operator*( const asset& a, int64_t b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, int64_t b )
operator *	asset.hpp	/^      friend asset operator*( int64_t b, const asset& a ) {$/;"	f	struct:eosio::asset	access:friend	signature:( int64_t b, const asset& a )
operator *	binary_extension.hpp	/^         constexpr T& operator*()& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
operator *	binary_extension.hpp	/^         constexpr T&& operator*()&& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
operator *	binary_extension.hpp	/^         constexpr const T& operator*()const& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
operator *	binary_extension.hpp	/^         constexpr const T&& operator*()const&& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
operator *	multi_index.hpp	/^                  const T& operator*()const { return *static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:() const
operator *	multi_index.hpp	/^         const T& operator*()const { return *static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:() const
operator *=	asset.hpp	/^      asset& operator*=( int64_t a ) {$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a )
operator +	asset.hpp	/^      friend extended_asset operator + ( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator +	asset.hpp	/^      inline friend asset operator+( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator +	time.hpp	/^        friend microseconds operator + (const  microseconds& l, const microseconds& r ) { return microseconds(l._count+r._count); }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& l, const microseconds& r )
operator +	time.hpp	/^        friend time_point   operator + ( const time_point_sec& t, const microseconds& m )   { return time_point(t) + m;             }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& t, const microseconds& m )
operator +	time.hpp	/^        time_point   operator + (const microseconds& m) const { return time_point(elapsed+m); }$/;"	f	class:eosio::time_point	access:public	signature:(const microseconds& m) const
operator +	time.hpp	/^        time_point   operator + (const time_point& m) const { return time_point(elapsed+m.elapsed); }$/;"	f	class:eosio::time_point	access:public	signature:(const time_point& m) const
operator +	time.hpp	/^        time_point_sec   operator +( uint32_t offset )const { return time_point_sec(utc_seconds + offset); }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t offset ) const
operator ++	multi_index.hpp	/^                  const_iterator operator++(int){$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:(int)
operator ++	multi_index.hpp	/^                  const_iterator& operator++() {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:()
operator ++	multi_index.hpp	/^         const_iterator operator++(int) {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:(int)
operator ++	multi_index.hpp	/^         const_iterator& operator++() {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:()
operator ++	varint.hpp	/^    signed_int operator++(int) { return value++; }$/;"	f	struct:signed_int	access:public	signature:(int)
operator ++	varint.hpp	/^    signed_int& operator++(){ ++value; return *this; }$/;"	f	struct:signed_int	access:public	signature:()
operator +=	asset.hpp	/^      asset& operator+=( const asset& a ) {$/;"	f	struct:eosio::asset	access:public	signature:( const asset& a )
operator +=	asset.hpp	/^      friend extended_asset& operator+=( extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( extended_asset& a, const extended_asset& b )
operator +=	time.hpp	/^        microseconds& operator+=(const microseconds& c) { _count += c._count; return *this; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c)
operator +=	time.hpp	/^        time_point&  operator += ( const microseconds& m)                           { elapsed+=m; return *this;                 }$/;"	f	class:eosio::time_point	access:public	signature:( const microseconds& m)
operator +=	time.hpp	/^        time_point_sec&  operator += ( microseconds m ) { utc_seconds+=m.to_seconds(); return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( microseconds m )
operator +=	time.hpp	/^        time_point_sec&  operator += ( time_point_sec m ) { utc_seconds+=m.utc_seconds; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( time_point_sec m )
operator +=	time.hpp	/^        time_point_sec&  operator += ( uint32_t m ) { utc_seconds+=m; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t m )
operator -	asset.hpp	/^      asset operator-()const {$/;"	f	struct:eosio::asset	access:public	signature:() const
operator -	asset.hpp	/^      extended_asset operator-()const {$/;"	f	struct:eosio::extended_asset	access:public	signature:() const
operator -	asset.hpp	/^      friend extended_asset operator - ( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator -	asset.hpp	/^      inline friend asset operator-( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator -	time.hpp	/^        friend microseconds operator - ( const time_point& t, const time_point_sec& m ) { return time_point(t) - time_point(m); }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point& t, const time_point_sec& m )
operator -	time.hpp	/^        friend microseconds operator - ( const time_point_sec& t, const time_point_sec& m ) { return time_point(t) - time_point(m); }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& t, const time_point_sec& m )
operator -	time.hpp	/^        friend microseconds operator - (const  microseconds& l, const microseconds& r ) { return microseconds(l._count-r._count); }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& l, const microseconds& r )
operator -	time.hpp	/^        friend time_point   operator - ( const time_point_sec& t, const microseconds& m )   { return time_point(t) - m;             }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& t, const microseconds& m )
operator -	time.hpp	/^        microseconds operator - (const time_point& m) const { return microseconds(elapsed.count() - m.elapsed.count()); }$/;"	f	class:eosio::time_point	access:public	signature:(const time_point& m) const
operator -	time.hpp	/^        time_point   operator - (const microseconds& m) const { return time_point(elapsed-m); }$/;"	f	class:eosio::time_point	access:public	signature:(const microseconds& m) const
operator -	time.hpp	/^        time_point_sec   operator -( uint32_t offset )const { return time_point_sec(utc_seconds - offset); }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t offset ) const
operator --	multi_index.hpp	/^                  const_iterator operator--(int){$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:(int)
operator --	multi_index.hpp	/^                  const_iterator& operator--() {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:()
operator --	multi_index.hpp	/^         const_iterator operator--(int) {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:(int)
operator --	multi_index.hpp	/^         const_iterator& operator--() {$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:()
operator -=	asset.hpp	/^      asset& operator-=( const asset& a ) {$/;"	f	struct:eosio::asset	access:public	signature:( const asset& a )
operator -=	asset.hpp	/^      friend extended_asset& operator-=( extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( extended_asset& a, const extended_asset& b )
operator -=	time.hpp	/^        microseconds& operator-=(const microseconds& c) { _count -= c._count; return *this; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c)
operator -=	time.hpp	/^        time_point&  operator -= ( const microseconds& m)                           { elapsed-=m; return *this;                 }$/;"	f	class:eosio::time_point	access:public	signature:( const microseconds& m)
operator -=	time.hpp	/^        time_point_sec&  operator -= ( microseconds m ) { utc_seconds-=m.to_seconds(); return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( microseconds m )
operator -=	time.hpp	/^        time_point_sec&  operator -= ( time_point_sec m ) { utc_seconds-=m.utc_seconds; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( time_point_sec m )
operator -=	time.hpp	/^        time_point_sec&  operator -= ( uint32_t m ) { utc_seconds-=m; return *this; }$/;"	f	class:eosio::time_point_sec	access:public	signature:( uint32_t m )
operator ->	binary_extension.hpp	/^         constexpr T* operator->() {$/;"	f	class:eosio::binary_extension	access:public	signature:()
operator ->	binary_extension.hpp	/^         constexpr const T* operator->()const {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
operator ->	multi_index.hpp	/^                  const T* operator->()const { return static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::index::const_iterator	access:public	signature:() const
operator ->	multi_index.hpp	/^         const T* operator->()const { return static_cast<const T*>(_item); }$/;"	f	struct:eosio::multi_index::const_iterator	access:public	signature:() const
operator /	asset.hpp	/^      friend asset operator\/( const asset& a, int64_t b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, int64_t b )
operator /	asset.hpp	/^      friend int64_t operator\/( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator /=	asset.hpp	/^      asset& operator\/=( int64_t a ) {$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a )
operator <	asset.hpp	/^      friend bool operator<( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator <	asset.hpp	/^      friend bool operator<( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator <	fixed_bytes.hpp	/^   bool operator <(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
operator <	fixed_key.hpp	/^   bool operator <(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {$/;"	f	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator <	fixed_key.hpp	/^   bool operator <(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator <	name.hpp	/^      friend constexpr bool operator < ( const name& a, const name& b ) {$/;"	f	struct:eosio::name	access:friend	signature:( const name& a, const name& b )
operator <	privileged.hpp	/^      friend constexpr bool operator < ( const producer_key& a, const producer_key& b ) {$/;"	f	struct:eosio::producer_key	access:friend	signature:( const producer_key& a, const producer_key& b )
operator <	symbol.hpp	/^      friend constexpr bool operator < ( const extended_symbol& a, const extended_symbol& b ) {$/;"	f	class:eosio::extended_symbol	access:friend	signature:( const extended_symbol& a, const extended_symbol& b )
operator <	symbol.hpp	/^      friend constexpr bool operator < ( const symbol& a, const symbol& b ) {$/;"	f	class:eosio::symbol	access:friend	signature:( const symbol& a, const symbol& b )
operator <	symbol.hpp	/^      friend constexpr bool operator < ( const symbol_code& a, const symbol_code& b ) {$/;"	f	class:eosio::symbol_code	access:friend	signature:( const symbol_code& a, const symbol_code& b )
operator <	time.hpp	/^         bool   operator < ( const block_timestamp& t )const   { return slot <  t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
operator <	time.hpp	/^        bool   operator < ( const time_point& t )const                              { return elapsed._count < t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
operator <	time.hpp	/^        friend bool      operator < ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds < b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
operator <	time.hpp	/^        friend bool operator<(const microseconds& a, const microseconds& b){ return a._count < b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
operator <	varint.hpp	/^    friend bool operator<( const int32_t& i, const signed_int& v )     { return i       < v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
operator <	varint.hpp	/^    friend bool operator<( const signed_int& i, const int32_t& v )     { return i.value < v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
operator <	varint.hpp	/^    friend bool operator<( const signed_int& i, const signed_int& v )  { return i.value < v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
operator <	varint.hpp	/^    friend bool operator<( const uint32_t& i, const unsigned_int& v )      { return i       < v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
operator <	varint.hpp	/^    friend bool operator<( const unsigned_int& i, const uint32_t& v )      { return i.value < v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
operator <	varint.hpp	/^    friend bool operator<( const unsigned_int& i, const unsigned_int& v )  { return i.value < v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const T (&v)[N] ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const T (&v)[N] )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const boost::container::flat_set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const boost::container::flat_set<T>& s )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::array<T,N>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::array<T,N>& v )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::map<K,V>& m )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::set<T>& s )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::string& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::string& v )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::vector<T>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::vector<T>& v )
operator <<	datastream.hpp	/^DataStream& operator << ( DataStream& ds, const std::vector<char>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::vector<char>& v )
operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const T& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const T& v )
operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const boost::container::flat_map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const boost::container::flat_map<K,V>& m )
operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const std::pair<T1, T2>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::pair<T1, T2>& t )
operator <<	datastream.hpp	/^DataStream& operator<<( DataStream& ds, const std::tuple<Args...>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, const std::tuple<Args...>& t )
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const ::eosio::ignore<T>& val) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const ::eosio::ignore<T>& val)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const ::eosio::ignore_wrapper<T>& val) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const ::eosio::ignore_wrapper<T>& val)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const bool& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const bool& d)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_checksum160& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_checksum160& cs)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_checksum256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_checksum256& d)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_checksum512& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_checksum512& cs)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const capi_public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const capi_public_key& pubkey)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::binary_extension<T>& be) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::binary_extension<T>& be)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::public_key& pubkey)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::signature& sig) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::signature& sig)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::symbol sym) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::symbol sym)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const eosio::symbol_code sym_code) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const eosio::symbol_code sym_code)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const fixed_bytes<Size>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const fixed_bytes<Size>& d)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const key256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const key256& d)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::deque<T>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::deque<T>& d)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::list<T>& l) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::list<T>& l)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::optional<T>& opt) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::optional<T>& opt)
operator <<	datastream.hpp	/^inline datastream<Stream>& operator<<(datastream<Stream>& ds, const std::variant<Ts...>& var) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, const std::variant<Ts...>& var)
operator <<	print.hpp	/^   inline iostream& operator<<( iostream& out, const T& v ) {$/;"	f	namespace:eosio	signature:( iostream& out, const T& v )
operator <<	varint.hpp	/^    friend DataStream& operator << ( DataStream& ds, const signed_int& v ){$/;"	f	struct:signed_int	access:friend	signature:( DataStream& ds, const signed_int& v )
operator <<	varint.hpp	/^    friend DataStream& operator << ( DataStream& ds, const unsigned_int& v ){$/;"	f	struct:unsigned_int	access:friend	signature:( DataStream& ds, const unsigned_int& v )
operator <=	asset.hpp	/^      friend bool operator<=( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator <=	asset.hpp	/^      friend bool operator<=( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator <=	fixed_bytes.hpp	/^   bool operator <=(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
operator <=	fixed_key.hpp	/^   bool operator <=(const fixed_key<Size> &c1, const fixed_key<Size> &c2) {$/;"	f	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator <=	fixed_key.hpp	/^   bool operator <=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator <=	time.hpp	/^         bool   operator <=( const block_timestamp& t )const   { return slot <= t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
operator <=	time.hpp	/^        bool   operator <=( const time_point& t )const                              { return elapsed._count <=t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
operator <=	time.hpp	/^        friend bool      operator <= ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds <= b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
operator <=	time.hpp	/^        friend bool operator<=(const microseconds& a, const microseconds& b){ return a._count <= b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
operator =	time.hpp	/^         void operator = (const time_point& t ) {$/;"	f	class:eosio::block_timestamp	access:public	signature:(const time_point& t )
operator =	time.hpp	/^        time_point_sec operator = ( const eosio::time_point& t )$/;"	f	class:eosio::time_point_sec	access:public	signature:( const eosio::time_point& t )
operator =	varint.hpp	/^    signed_int& operator=( const T& v ) { value = v; return *this; }$/;"	f	struct:signed_int	access:public	signature:( const T& v )
operator =	varint.hpp	/^    unsigned_int& operator=( uint32_t v ) { value = v; return *this; }$/;"	f	struct:unsigned_int	access:public	signature:( uint32_t v )
operator ==	action.hpp	/^      friend constexpr bool operator == ( const permission_level& a, const permission_level& b ) {$/;"	f	struct:eosio::permission_level	access:friend	signature:( const permission_level& a, const permission_level& b )
operator ==	asset.hpp	/^      friend bool operator==( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator ==	asset.hpp	/^      friend bool operator==( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator ==	crypto.hpp	/^      friend bool operator == ( const public_key& a, const public_key& b ) {$/;"	f	struct:eosio::public_key	access:friend	signature:( const public_key& a, const public_key& b )
operator ==	crypto.hpp	/^      friend bool operator == ( const signature& a, const signature& b ) {$/;"	f	struct:eosio::signature	access:friend	signature:( const signature& a, const signature& b )
operator ==	fixed_bytes.hpp	/^   bool operator ==(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
operator ==	fixed_key.hpp	/^   bool operator ==(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator ==	multi_index.hpp	/^                  friend bool operator == ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
operator ==	multi_index.hpp	/^         friend bool operator == ( const const_iterator& a, const const_iterator& b ) {$/;"	f	struct:eosio::multi_index::const_iterator	access:friend	signature:( const const_iterator& a, const const_iterator& b )
operator ==	name.hpp	/^      friend constexpr bool operator == ( const name& a, const name& b ) {$/;"	f	struct:eosio::name	access:friend	signature:( const name& a, const name& b )
operator ==	symbol.hpp	/^      friend constexpr bool operator == ( const extended_symbol& a, const extended_symbol& b ) {$/;"	f	class:eosio::extended_symbol	access:friend	signature:( const extended_symbol& a, const extended_symbol& b )
operator ==	symbol.hpp	/^      friend constexpr bool operator == ( const symbol& a, const symbol& b ) {$/;"	f	class:eosio::symbol	access:friend	signature:( const symbol& a, const symbol& b )
operator ==	symbol.hpp	/^      friend constexpr bool operator == ( const symbol_code& a, const symbol_code& b ) {$/;"	f	class:eosio::symbol_code	access:friend	signature:( const symbol_code& a, const symbol_code& b )
operator ==	time.hpp	/^         bool   operator ==( const block_timestamp& t )const   { return slot == t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
operator ==	time.hpp	/^        bool   operator ==( const time_point& t )const                              { return elapsed._count ==t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
operator ==	time.hpp	/^        bool operator==(const microseconds& c)const { return _count == c._count; }$/;"	f	class:eosio::microseconds	access:public	signature:(const microseconds& c) const
operator ==	time.hpp	/^        friend bool      operator == ( const time_point_sec& a, const time_point_sec& b ) { return a.utc_seconds == b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
operator ==	varint.hpp	/^    friend bool operator==( const int32_t& i, const signed_int& v )    { return i       == v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
operator ==	varint.hpp	/^    friend bool operator==( const signed_int& i, const int32_t& v )    { return i.value == v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
operator ==	varint.hpp	/^    friend bool operator==( const signed_int& i, const signed_int& v ) { return i.value == v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
operator ==	varint.hpp	/^    friend bool operator==( const uint32_t& i, const unsigned_int& v )     { return i       == v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
operator ==	varint.hpp	/^    friend bool operator==( const unsigned_int& i, const uint32_t& v )     { return i.value == v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
operator ==	varint.hpp	/^    friend bool operator==( const unsigned_int& i, const unsigned_int& v ) { return i.value == v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
operator >	asset.hpp	/^      friend bool operator>( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator >	fixed_bytes.hpp	/^   bool operator >(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
operator >	fixed_key.hpp	/^   bool operator >(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator >	time.hpp	/^         bool   operator > ( const block_timestamp& t )const   { return slot >  t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
operator >	time.hpp	/^        bool   operator > ( const time_point& t )const                              { return elapsed._count > t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
operator >	time.hpp	/^        friend bool      operator > ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds > b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
operator >	time.hpp	/^        friend bool operator>(const microseconds& a, const microseconds& b){ return a._count > b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
operator >=	asset.hpp	/^      friend bool operator>=( const asset& a, const asset& b ) {$/;"	f	struct:eosio::asset	access:friend	signature:( const asset& a, const asset& b )
operator >=	asset.hpp	/^      friend bool operator>=( const extended_asset& a, const extended_asset& b ) {$/;"	f	struct:eosio::extended_asset	access:friend	signature:( const extended_asset& a, const extended_asset& b )
operator >=	fixed_bytes.hpp	/^   bool operator >=(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_bytes<Size> &c1, const fixed_bytes<Size> &c2)
operator >=	fixed_key.hpp	/^   bool operator >=(const fixed_key<Size> &c1, const fixed_key<Size> &c2);$/;"	p	namespace:eosio	signature:(const fixed_key<Size> &c1, const fixed_key<Size> &c2)
operator >=	fixed_key.hpp	/^   bool operator >=(const fixed_key<Size>& c1, const fixed_key<Size>& c2) {$/;"	f	namespace:eosio	signature:(const fixed_key<Size>& c1, const fixed_key<Size>& c2)
operator >=	time.hpp	/^         bool   operator >=( const block_timestamp& t )const   { return slot >= t.slot; }$/;"	f	class:eosio::block_timestamp	access:public	signature:( const block_timestamp& t ) const
operator >=	time.hpp	/^        bool   operator >=( const time_point& t )const                              { return elapsed._count >=t.elapsed._count; }$/;"	f	class:eosio::time_point	access:public	signature:( const time_point& t ) const
operator >=	time.hpp	/^        friend bool      operator >= ( const time_point_sec& a, const time_point_sec& b )  { return a.utc_seconds >= b.utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:friend	signature:( const time_point_sec& a, const time_point_sec& b )
operator >=	time.hpp	/^        friend bool operator>=(const microseconds& a, const microseconds& b){ return a._count >= b._count; }$/;"	f	class:eosio::microseconds	access:friend	signature:(const microseconds& a, const microseconds& b)
operator >=	varint.hpp	/^    friend bool operator>=( const int32_t& i, const signed_int& v )    { return i       >= v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
operator >=	varint.hpp	/^    friend bool operator>=( const signed_int& i, const int32_t& v )    { return i.value >= v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
operator >=	varint.hpp	/^    friend bool operator>=( const signed_int& i, const signed_int& v ) { return i.value >= v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
operator >=	varint.hpp	/^    friend bool operator>=( const uint32_t& i, const unsigned_int& v )     { return i       >= v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
operator >=	varint.hpp	/^    friend bool operator>=( const unsigned_int& i, const uint32_t& v )     { return i.value >= v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
operator >=	varint.hpp	/^    friend bool operator>=( const unsigned_int& i, const unsigned_int& v ) { return i.value >= v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, T (&v)[N] ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, T (&v)[N] )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, T ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, T )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, boost::container::flat_set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, boost::container::flat_set<T>& s )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::array<T,N>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::array<T,N>& v )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::map<K,V>& m )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::set<T>& s ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::set<T>& s )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::string& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::string& v )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::vector<T>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::vector<T>& v )
operator >>	datastream.hpp	/^DataStream& operator >> ( DataStream& ds, std::vector<char>& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::vector<char>& v )
operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, T& v ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, T& v )
operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, boost::container::flat_map<K,V>& m ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, boost::container::flat_map<K,V>& m )
operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, std::pair<T1, T2>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::pair<T1, T2>& t )
operator >>	datastream.hpp	/^DataStream& operator>>( DataStream& ds, std::tuple<Args...>& t ) {$/;"	f	namespace:eosio	signature:( DataStream& ds, std::tuple<Args...>& t )
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, ::eosio::ignore<T>) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, ::eosio::ignore<T>)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, bool& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, bool& d)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_checksum160& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_checksum160& cs)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_checksum256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_checksum256& d)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_checksum512& cs) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_checksum512& cs)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, capi_public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, capi_public_key& pubkey)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::binary_extension<T>& be) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::binary_extension<T>& be)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::public_key& pubkey) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::public_key& pubkey)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::signature& sig) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::signature& sig)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::symbol& sym) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::symbol& sym)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, eosio::symbol_code& sym_code) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, eosio::symbol_code& sym_code)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, fixed_bytes<Size>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, fixed_bytes<Size>& d)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, key256& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, key256& d)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::deque<T>& d) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::deque<T>& d)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::list<T>& l) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::list<T>& l)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::optional<T>& opt) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::optional<T>& opt)
operator >>	datastream.hpp	/^inline datastream<Stream>& operator>>(datastream<Stream>& ds, std::variant<Ts...>& var) {$/;"	f	namespace:eosio	signature:(datastream<Stream>& ds, std::variant<Ts...>& var)
operator >>	varint.hpp	/^    friend DataStream& operator >> ( DataStream& ds, signed_int& vi ){$/;"	f	struct:signed_int	access:friend	signature:( DataStream& ds, signed_int& vi )
operator >>	varint.hpp	/^    friend DataStream& operator >> ( DataStream& ds, unsigned_int& vi ){$/;"	f	struct:unsigned_int	access:friend	signature:( DataStream& ds, unsigned_int& vi )
operator T	ignore.hpp	/^      constexpr operator T() { return value; }$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
operator T	varint.hpp	/^    operator T()const { return static_cast<T>(value); }$/;"	f	struct:unsigned_int	access:public	signature:() const
operator bool	binary_extension.hpp	/^         constexpr explicit operator bool()const { return _has_value; }$/;"	f	class:eosio::binary_extension	access:public	signature:() const
operator bool	name.hpp	/^      constexpr explicit operator bool()const { return value != 0; }$/;"	f	struct:eosio::name	access:public	signature:() const
operator bool	symbol.hpp	/^      constexpr explicit operator bool()const { return value != 0; }$/;"	f	class:eosio::symbol	access:public	signature:() const
operator bool	symbol.hpp	/^      constexpr explicit operator bool()const { return value != 0; }$/;"	f	class:eosio::symbol_code	access:public	signature:() const
operator ignore<T>	ignore.hpp	/^      constexpr operator ignore<T>() { return {}; }$/;"	f	struct:eosio::ignore_wrapper	access:public	signature:()
operator int32_t	varint.hpp	/^    operator int32_t()const { return value; }$/;"	f	struct:signed_int	access:public	signature:() const
operator raw	name.hpp	/^      constexpr operator raw()const { return raw(value); }$/;"	f	struct:eosio::name	access:public	signature:() const
operator time_point	time.hpp	/^         operator time_point() const {$/;"	f	class:eosio::block_timestamp	access:public	signature:() const
operator time_point	time.hpp	/^        operator time_point()const { return time_point( eosio::seconds( utc_seconds) ); }$/;"	f	class:eosio::time_point_sec	access:public	signature:() const
operator uint64_t	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	f	struct:eosio::multi_index::intc	access:public	signature:() const
pack	datastream.hpp	/^std::vector<char> pack( const T& value ) {$/;"	f	namespace:eosio	signature:( const T& value )
pack_size	datastream.hpp	/^size_t pack_size( const T& value ) {$/;"	f	namespace:eosio	signature:( const T& value )
padded_bytes	fixed_bytes.hpp	/^         static constexpr size_t padded_bytes() { return num_words() * sizeof(word_t) - Size; }$/;"	f	class:eosio::fixed_bytes	access:public	signature:()
padded_bytes	fixed_key.hpp	/^         static constexpr size_t padded_bytes() { return num_words() * sizeof(word_t) - Size; }$/;"	f	class:eosio::fixed_key	access:public	signature:()
permission	action.hpp	/^      name    permission;$/;"	m	struct:eosio::permission_level	access:public
permission_level	action.hpp	/^      permission_level( name a, name p ):actor(a),permission(p){}$/;"	f	struct:eosio::permission_level	access:public	signature:( name a, name p )
permission_level	action.hpp	/^      permission_level(){}$/;"	f	struct:eosio::permission_level	access:public	signature:()
permission_level	action.hpp	/^   struct permission_level {$/;"	s	namespace:eosio
permissions	action.hpp	/^      std::vector<eosio::permission_level> permissions;$/;"	m	struct:eosio::action_wrapper	access:public
permissions	action.hpp	/^      std::vector<eosio::permission_level> permissions;$/;"	m	struct:eosio::variant_action_wrapper	access:public
pk_value	singleton.hpp	/^      constexpr static uint64_t pk_value = static_cast<uint64_t>(SingletonName);$/;"	m	class:eosio::singleton	access:private
pos	datastream.hpp	/^      T pos()const { return _pos; }$/;"	f	class:eosio::datastream	access:public	signature:() const
precision	symbol.hpp	/^      constexpr uint8_t precision()const             { return static_cast<uint8_t>( value & 0xFFull ); }$/;"	f	class:eosio::symbol	access:public	signature:() const
primary_key	singleton.hpp	/^         uint64_t primary_key() const { return pk_value; }$/;"	f	struct:eosio::singleton::row	access:public	signature:() const
print	asset.hpp	/^      void print()const {$/;"	f	struct:eosio::asset	access:public	signature:() const
print	asset.hpp	/^      void print()const {$/;"	f	struct:eosio::extended_asset	access:public	signature:() const
print	print.hpp	/^   inline void print( T num ) {$/;"	f	namespace:eosio	signature:( T num )
print	print.hpp	/^   inline void print( T&& t ) {$/;"	f	namespace:eosio	signature:( T&& t )
print	print.hpp	/^   inline void print( const char* ptr ) {$/;"	f	namespace:eosio	signature:( const char* ptr )
print	print.hpp	/^   inline void print( const fixed_bytes<Size>& val ) {$/;"	f	namespace:eosio	signature:( const fixed_bytes<Size>& val )
print	print.hpp	/^   inline void print( double num ) { printdf( num ); }$/;"	f	namespace:eosio	signature:( double num )
print	print.hpp	/^   inline void print( eosio::symbol_code sym_code ) {$/;"	f	namespace:eosio	signature:( eosio::symbol_code sym_code )
print	print.hpp	/^   inline void print( fixed_bytes<Size>& val ) {$/;"	f	namespace:eosio	signature:( fixed_bytes<Size>& val )
print	print.hpp	/^   inline void print( float num ) { printsf( num ); }$/;"	f	namespace:eosio	signature:( float num )
print	print.hpp	/^   inline void print( long double num ) { printqf( &num ); }$/;"	f	namespace:eosio	signature:( long double num )
print	print.hpp	/^   inline void print( name name ) {$/;"	f	namespace:eosio	signature:( name name )
print	print.hpp	/^   void print( Arg&& a, Args&&... args ) {$/;"	f	namespace:eosio	signature:( Arg&& a, Args&&... args )
print	symbol.hpp	/^      void print( bool show_precision = true )const {$/;"	f	class:eosio::extended_symbol	access:public	signature:( bool show_precision = true ) const
print	symbol.hpp	/^      void print( bool show_precision = true )const {$/;"	f	class:eosio::symbol	access:public	signature:( bool show_precision = true ) const
print_f	print.hpp	/^   inline void print_f( const char* s ) {$/;"	f	namespace:eosio	signature:( const char* s )
print_f	print.hpp	/^   inline void print_f( const char* s, Arg val, Args... rest ) {$/;"	f	namespace:eosio	signature:( const char* s, Arg val, Args... rest )
printdf	print.h	/^   void printdf(double value);$/;"	p	signature:(double value)
printhex	print.h	/^    void printhex( const void* data, uint32_t datalen );$/;"	p	signature:( const void* data, uint32_t datalen )
printi	print.h	/^   void printi( int64_t value );$/;"	p	signature:( int64_t value )
printi128	print.h	/^   void printi128( const int128_t* value );$/;"	p	signature:( const int128_t* value )
printn	print.h	/^   void printn( uint64_t name );$/;"	p	signature:( uint64_t name )
printqf	print.h	/^   void printqf(const long double* value);$/;"	p	signature:(const long double* value)
prints	print.h	/^   void prints( const char* cstr );$/;"	p	signature:( const char* cstr )
prints_l	print.h	/^   void prints_l( const char* cstr, uint32_t len);$/;"	p	signature:( const char* cstr, uint32_t len)
printsf	print.h	/^   void printsf(float value);$/;"	p	signature:(float value)
printui	print.h	/^   void printui( uint64_t value );$/;"	p	signature:( uint64_t value )
printui128	print.h	/^   void printui128( const uint128_t* value );$/;"	p	signature:( const uint128_t* value )
producer_key	privileged.hpp	/^   struct producer_key {$/;"	s	namespace:eosio
producer_name	privileged.hpp	/^      name             producer_name;$/;"	m	struct:eosio::producer_key	access:public
producer_schedule	producer_schedule.hpp	/^   struct producer_schedule {$/;"	s	namespace:eosio
producers	producer_schedule.hpp	/^      std::vector<producer_key>    producers;$/;"	m	struct:eosio::producer_schedule	access:public
ptr	eosiolib.cpp	/^            char* ptr() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
public_key	crypto.hpp	/^   struct public_key {$/;"	s	namespace:eosio
publication_time	action.h	/^   uint64_t  publication_time();$/;"	p	signature:()
put	datastream.hpp	/^      inline bool put(char c) {$/;"	f	class:eosio::datastream	access:public	signature:(char c)
put	datastream.hpp	/^     inline bool     put(char )                      { ++_size; return  true;    }$/;"	f	class:eosio::datastream	access:public	signature:(char )
quantity	asset.hpp	/^      asset quantity;$/;"	m	struct:eosio::extended_asset	access:public
raw	name.hpp	/^      enum class raw : uint64_t {};$/;"	c	struct:eosio::name	inherits:uint64_t	access:public
raw	symbol.hpp	/^      constexpr uint64_t raw()const                  { return value; }$/;"	f	class:eosio::symbol	access:public	signature:() const
raw	symbol.hpp	/^      constexpr uint64_t raw()const { return value; }$/;"	f	class:eosio::symbol_code	access:public	signature:() const
rbegin	multi_index.hpp	/^            const_reverse_iterator rbegin()const  { return crbegin(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
rbegin	multi_index.hpp	/^      const_reverse_iterator rbegin()const  { return crbegin(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
read	datastream.hpp	/^      inline bool read( char* d, size_t s ) {$/;"	f	class:eosio::datastream	access:public	signature:( char* d, size_t s )
read_action_data	action.h	/^   uint32_t read_action_data( void* msg, uint32_t len );$/;"	p	signature:( void* msg, uint32_t len )
read_transaction	transaction.h	/^   size_t read_transaction(char *buffer, size_t size);$/;"	p	signature:(char *buffer, size_t size)
realloc	eosiolib.cpp	/^      void* realloc(void* ptr, uint32_t size)$/;"	f	class:eosio::memory_manager	file:	access:private	signature:(void* ptr, uint32_t size)
realloc	eosiolib.cpp	/^   friend void* ::realloc(void* ptr, size_t size);$/;"	p	class:eosio::memory_manager	file:	access:friend	signature:(void* ptr, size_t size)
realloc	eosiolib.cpp	/^void* realloc(void* ptr, size_t size)$/;"	f	signature:(void* ptr, size_t size)
realloc	memory.hpp	/^void* realloc(void* ptr, size_t size);$/;"	p	signature:(void* ptr, size_t size)
realloc_in_place	eosiolib.cpp	/^         char* realloc_in_place(char* const ptr, uint32_t size, uint32_t* orig_ptr_size)$/;"	f	class:eosio::memory_manager::memory	access:public	signature:(char* const ptr, uint32_t size, uint32_t* orig_ptr_size)
recover_key	crypto.cpp	/^   eosio::public_key recover_key( const eosio::checksum256& digest, const eosio::signature& sig ) {$/;"	f	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig )
recover_key	crypto.h	/^int recover_key( const capi_checksum256* digest, const char* sig, size_t siglen, char* pub, size_t publen );$/;"	p	signature:( const capi_checksum256* digest, const char* sig, size_t siglen, char* pub, size_t publen )
recover_key	crypto.hpp	/^   eosio::public_key recover_key( const eosio::checksum256& digest, const eosio::signature& sig );$/;"	p	namespace:eosio	signature:( const eosio::checksum256& digest, const eosio::signature& sig )
ref_block_num	transaction.hpp	/^      uint16_t        ref_block_num;$/;"	m	class:eosio::transaction_header	access:public
ref_block_prefix	transaction.hpp	/^      uint32_t        ref_block_prefix;$/;"	m	class:eosio::transaction_header	access:public
remaining	datastream.hpp	/^      inline size_t remaining()const  { return _end - _pos; }$/;"	f	class:eosio::datastream	access:public	signature:() const
remaining	datastream.hpp	/^     inline size_t   remaining()const                 { return 0;                 }$/;"	f	class:eosio::datastream	access:public	signature:() const
remove	singleton.hpp	/^         void remove( ) {$/;"	f	class:eosio::singleton	access:public	signature:( )
rend	multi_index.hpp	/^            const_reverse_iterator rend()const    { return crend(); }$/;"	f	struct:eosio::multi_index::index	access:public	signature:() const
rend	multi_index.hpp	/^      const_reverse_iterator rend()const    { return crend(); }$/;"	f	class:eosio::multi_index	access:public	signature:() const
require_auth	action.h	/^   void require_auth( capi_name name );$/;"	p	signature:( capi_name name )
require_auth	action.hpp	/^   inline void require_auth( const permission_level& level ) {$/;"	f	namespace:eosio	signature:( const permission_level& level )
require_auth	action.hpp	/^   inline void require_auth( name n ) {$/;"	f	namespace:eosio	signature:( name n )
require_auth2	action.h	/^   void require_auth2( capi_name name, capi_name permission );$/;"	p	signature:( capi_name name, capi_name permission )
require_find	multi_index.hpp	/^            const_iterator require_find( const secondary_key_type& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary, const char* error_msg =  ) const
require_find	multi_index.hpp	/^            const_iterator require_find( secondary_key_type&& secondary, const char* error_msg = "unable to find secondary key" )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary, const char* error_msg =  ) const
require_find	multi_index.hpp	/^      const_iterator require_find( uint64_t primary, const char* error_msg = "unable to find key" )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary, const char* error_msg =  ) const
require_recipient	action.h	/^   void require_recipient( capi_name name );$/;"	p	signature:( capi_name name )
require_recipient	action.hpp	/^   inline void require_recipient( name notify_account ){$/;"	f	namespace:eosio	signature:( name notify_account )
require_recipient	action.hpp	/^   void require_recipient( name notify_account, accounts... remaining_accounts ){$/;"	f	namespace:eosio	signature:( name notify_account, accounts... remaining_accounts )
reset	binary_extension.hpp	/^         void reset() {$/;"	f	class:eosio::binary_extension	access:public	signature:()
result_type	multi_index.hpp	/^  typedef typename std::remove_reference<Type>::type result_type;$/;"	t	struct:eosio::const_mem_fun	access:public
ripemd160	crypto.cpp	/^   eosio::checksum160 ripemd160( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
ripemd160	crypto.h	/^void ripemd160( const char* data, uint32_t length, capi_checksum160* hash );$/;"	p	signature:( const char* data, uint32_t length, capi_checksum160* hash )
ripemd160	crypto.hpp	/^   eosio::checksum160 ripemd160( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
row	singleton.hpp	/^      struct row {$/;"	s	class:eosio::singleton	access:private
sbrk	eosiolib.cpp	/^void* sbrk(size_t num_bytes) {$/;"	f	signature:(size_t num_bytes)
sbrk	memory.hpp	/^void* sbrk(size_t num_bytes);$/;"	p	signature:(size_t num_bytes)
sec_since_epoch	time.hpp	/^        uint32_t            sec_since_epoch()const  { return uint32_t(elapsed.count() \/ 1000000); }$/;"	f	class:eosio::time_point	access:public	signature:() const
sec_since_epoch	time.hpp	/^        uint32_t sec_since_epoch()const { return utc_seconds; }$/;"	f	class:eosio::time_point_sec	access:public	signature:() const
secondary_extractor_type	multi_index.hpp	/^            typedef Extractor  secondary_extractor_type;$/;"	t	struct:eosio::multi_index::index	access:public
secondary_extractor_type	multi_index.hpp	/^   typedef Extractor secondary_extractor_type;$/;"	t	struct:eosio::indexed_by	access:public
secondary_index_db_functions	multi_index.hpp	/^   struct secondary_index_db_functions;$/;"	x
secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits;$/;"	x
secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<double> {$/;"	s	namespace:eosio::_multi_index_detail
secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<eosio::fixed_bytes<32>> {$/;"	s	namespace:eosio::_multi_index_detail
secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<eosio::key256> {$/;"	s	namespace:eosio::_multi_index_detail
secondary_key_traits	multi_index.hpp	/^   struct secondary_key_traits<long double> {$/;"	s	namespace:eosio::_multi_index_detail
secondary_key_type	multi_index.hpp	/^            typedef typename std::decay<decltype( Extractor()(nullptr) )>::type secondary_key_type;$/;"	t	struct:eosio::multi_index::index	access:public
seconds	time.hpp	/^  inline microseconds seconds( int64_t s ) { return microseconds( s * 1000000 ); }$/;"	f	namespace:eosio	signature:( int64_t s )
seekp	datastream.hpp	/^      inline bool seekp(size_t p) { _pos = _start + p; return _pos <= _end; }$/;"	f	class:eosio::datastream	access:public	signature:(size_t p)
seekp	datastream.hpp	/^     inline bool     seekp(size_t p)                  { _size = p;  return true;  }$/;"	f	class:eosio::datastream	access:public	signature:(size_t p)
send	action.hpp	/^      void send() const {$/;"	f	struct:eosio::action	access:public	signature:() const
send	action.hpp	/^      void send(Args&&... args)const {$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Args&&.... args) const
send	action.hpp	/^      void send(Args&&... args)const {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Args&&.... args) const
send	transaction.hpp	/^      void send(const uint128_t& sender_id, name payer, bool replace_existing = false) const {$/;"	f	class:eosio::transaction	access:public	signature:(const uint128_t& sender_id, name payer, bool replace_existing = false) const
send_context_free	action.hpp	/^      void send_context_free() const {$/;"	f	struct:eosio::action	access:public	signature:() const
send_context_free	action.hpp	/^      void send_context_free(Args&&... args) const {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Args&&.... args) const
send_context_free	action.hpp	/^      void send_context_free(Args&&... args)const {$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Args&&.... args) const
send_context_free_inline	action.h	/^   void send_context_free_inline(char *serialized_action, size_t size);$/;"	p	signature:(char *serialized_action, size_t size)
send_deferred	transaction.h	/^     void send_deferred(const uint128_t& sender_id, capi_name payer, const char *serialized_transaction, size_t size, uint32_t replace_existing = 0);$/;"	p	signature:(const uint128_t& sender_id, capi_name payer, const char *serialized_transaction, size_t size, uint32_t replace_existing = 0)
send_inline	action.h	/^   void send_inline(char *serialized_action, size_t size);$/;"	p	signature:(char *serialized_action, size_t size)
sender_id	transaction.hpp	/^      uint128_t          sender_id;$/;"	m	struct:eosio::onerror	access:public
sent_trx	transaction.hpp	/^      std::vector<char> sent_trx;$/;"	m	struct:eosio::onerror	access:public
set	singleton.hpp	/^         void set( const T& value, name bill_to_account ) {$/;"	f	class:eosio::singleton	access:public	signature:( const T& value, name bill_to_account )
set_active_producers	privileged.h	/^   void set_active_producers( char *producer_data, uint32_t producer_data_size );$/;"	p	signature:( char *producer_data, uint32_t producer_data_size )
set_amount	asset.hpp	/^      void set_amount( int64_t a ) {$/;"	f	struct:eosio::asset	access:public	signature:( int64_t a )
set_blockchain_parameters	eosiolib.cpp	/^   void set_blockchain_parameters(const eosio::blockchain_parameters& params) {$/;"	f	namespace:eosio	signature:(const eosio::blockchain_parameters& params)
set_blockchain_parameters	privileged.hpp	/^   void set_blockchain_parameters(const eosio::blockchain_parameters& params);$/;"	p	namespace:eosio	signature:(const eosio::blockchain_parameters& params)
set_blockchain_parameters_packed	privileged.h	/^   void set_blockchain_parameters_packed( char* data, uint32_t datalen );$/;"	p	signature:( char* data, uint32_t datalen )
set_from_word_sequence	fixed_bytes.hpp	/^         static void set_from_word_sequence(const Word* arr_begin, const Word* arr_end, fixed_bytes<Size>& key)$/;"	f	class:eosio::fixed_bytes	access:private	signature:(const Word* arr_begin, const Word* arr_end, fixed_bytes<Size>& key)
set_from_word_sequence	fixed_key.hpp	/^         static void set_from_word_sequence(Word* arr_begin, Word* arr_end, fixed_key<Size>& key)$/;"	f	class:eosio::fixed_key	access:private	signature:(Word* arr_begin, Word* arr_end, fixed_key<Size>& key)
set_privileged	privileged.h	/^   void set_privileged( capi_name account, bool is_priv );$/;"	p	signature:( capi_name account, bool is_priv )
set_proposed_producers	privileged.h	/^   int64_t set_proposed_producers( char *producer_data, uint32_t producer_data_size );$/;"	p	signature:( char *producer_data, uint32_t producer_data_size )
set_resource_limits	privileged.h	/^   void set_resource_limits( capi_name account, int64_t ram_bytes, int64_t net_weight, int64_t cpu_weight );$/;"	p	signature:( capi_name account, int64_t ram_bytes, int64_t net_weight, int64_t cpu_weight )
set_time_point	time.hpp	/^      void set_time_point(const time_point& t) {$/;"	f	class:eosio::block_timestamp	access:private	signature:(const time_point& t)
set_time_point	time.hpp	/^      void set_time_point(const time_point_sec& t) {$/;"	f	class:eosio::block_timestamp	access:private	signature:(const time_point_sec& t)
sha1	crypto.cpp	/^   eosio::checksum160 sha1( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
sha1	crypto.h	/^void sha1( const char* data, uint32_t length, capi_checksum160* hash );$/;"	p	signature:( const char* data, uint32_t length, capi_checksum160* hash )
sha1	crypto.hpp	/^   eosio::checksum160 sha1( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
sha256	crypto.cpp	/^   eosio::checksum256 sha256( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
sha256	crypto.h	/^void sha256( const char* data, uint32_t length, capi_checksum256* hash );$/;"	p	signature:( const char* data, uint32_t length, capi_checksum256* hash )
sha256	crypto.hpp	/^   eosio::checksum256 sha256( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
sha512	crypto.cpp	/^   eosio::checksum512 sha512( const char* data, uint32_t length ) {$/;"	f	namespace:eosio	signature:( const char* data, uint32_t length )
sha512	crypto.h	/^void sha512( const char* data, uint32_t length, capi_checksum512* hash );$/;"	p	signature:( const char* data, uint32_t length, capi_checksum512* hash )
sha512	crypto.hpp	/^   eosio::checksum512 sha512( const char* data, uint32_t length );$/;"	p	namespace:eosio	signature:( const char* data, uint32_t length )
signature	crypto.hpp	/^   struct signature {$/;"	s	namespace:eosio
signed_int	varint.hpp	/^    signed_int( int32_t v = 0 ):value(v){}$/;"	f	struct:signed_int	access:public	signature:( int32_t v = 0 )
signed_int	varint.hpp	/^struct signed_int {$/;"	s
signed_int::operator !=	varint.hpp	/^    friend bool operator!=( const int32_t& i, const signed_int& v )    { return i       != v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
signed_int::operator !=	varint.hpp	/^    friend bool operator!=( const signed_int& i, const int32_t& v )    { return i.value != v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
signed_int::operator !=	varint.hpp	/^    friend bool operator!=( const signed_int& i, const signed_int& v ) { return i.value != v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
signed_int::operator ++	varint.hpp	/^    signed_int operator++(int) { return value++; }$/;"	f	struct:signed_int	access:public	signature:(int)
signed_int::operator ++	varint.hpp	/^    signed_int& operator++(){ ++value; return *this; }$/;"	f	struct:signed_int	access:public	signature:()
signed_int::operator <	varint.hpp	/^    friend bool operator<( const int32_t& i, const signed_int& v )     { return i       < v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
signed_int::operator <	varint.hpp	/^    friend bool operator<( const signed_int& i, const int32_t& v )     { return i.value < v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
signed_int::operator <	varint.hpp	/^    friend bool operator<( const signed_int& i, const signed_int& v )  { return i.value < v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
signed_int::operator <<	varint.hpp	/^    friend DataStream& operator << ( DataStream& ds, const signed_int& v ){$/;"	f	struct:signed_int	access:friend	signature:( DataStream& ds, const signed_int& v )
signed_int::operator =	varint.hpp	/^    signed_int& operator=( const T& v ) { value = v; return *this; }$/;"	f	struct:signed_int	access:public	signature:( const T& v )
signed_int::operator ==	varint.hpp	/^    friend bool operator==( const int32_t& i, const signed_int& v )    { return i       == v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
signed_int::operator ==	varint.hpp	/^    friend bool operator==( const signed_int& i, const int32_t& v )    { return i.value == v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
signed_int::operator ==	varint.hpp	/^    friend bool operator==( const signed_int& i, const signed_int& v ) { return i.value == v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
signed_int::operator >=	varint.hpp	/^    friend bool operator>=( const int32_t& i, const signed_int& v )    { return i       >= v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const int32_t& i, const signed_int& v )
signed_int::operator >=	varint.hpp	/^    friend bool operator>=( const signed_int& i, const int32_t& v )    { return i.value >= v; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const int32_t& v )
signed_int::operator >=	varint.hpp	/^    friend bool operator>=( const signed_int& i, const signed_int& v ) { return i.value >= v.value; }$/;"	f	struct:signed_int	access:friend	signature:( const signed_int& i, const signed_int& v )
signed_int::operator >>	varint.hpp	/^    friend DataStream& operator >> ( DataStream& ds, signed_int& vi ){$/;"	f	struct:signed_int	access:friend	signature:( DataStream& ds, signed_int& vi )
signed_int::operator int32_t	varint.hpp	/^    operator int32_t()const { return value; }$/;"	f	struct:signed_int	access:public	signature:() const
signed_int::signed_int	varint.hpp	/^    signed_int( int32_t v = 0 ):value(v){}$/;"	f	struct:signed_int	access:public	signature:( int32_t v = 0 )
signed_int::value	varint.hpp	/^    int32_t value;$/;"	m	struct:signed_int	access:public
singleton	singleton.hpp	/^         singleton( name code, uint64_t scope ) : _t( code, scope ) {}$/;"	f	class:eosio::singleton	access:public	signature:( name code, uint64_t scope )
singleton	singleton.hpp	/^   class singleton$/;"	c	namespace:eosio
size	eosiolib.cpp	/^            uint32_t size() const$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:() const
size	eosiolib.cpp	/^            void size(uint32_t val)$/;"	f	class:eosio::memory_manager::memory::buffer_ptr	access:public	signature:(uint32_t val)
sizeof	eosio.hpp	/^static_assert( sizeof(long) == sizeof(int), "unexpected size difference" );$/;"	v
skip	datastream.hpp	/^      inline void skip( size_t s ){ _pos += s; }$/;"	f	class:eosio::datastream	access:public	signature:( size_t s )
skip	datastream.hpp	/^     inline bool     skip( size_t s )                 { _size += s; return true;  }$/;"	f	class:eosio::datastream	access:public	signature:( size_t s )
slot	time.hpp	/^         uint32_t slot;$/;"	m	class:eosio::block_timestamp	access:public
static_assert	action.hpp	/^         static_assert(detail::is_same<typename convert<T>::type, typename convert<typename std::tuple_element<I, deduced<Action>>::type>::type>::value);$/;"	p	struct:eosio::detail::check_types	access:public	signature:(detail::is_same<typename convert<T>::type, typename convert<typename std::tuple_element<I, deduced<Action>>::type>::type>::value)
static_assert	multi_index.hpp	/^      static_assert( sizeof...(Indices) <= 16, "multi_index only supports a maximum of 16 secondary indices" );$/;"	p	class:eosio::multi_index	access:private	signature:( sizeof....(Indices) <= 16,  )
suffix	name.hpp	/^      constexpr name suffix()const {$/;"	f	struct:eosio::name	access:public	signature:() const
symbol	asset.hpp	/^      symbol  symbol;$/;"	m	struct:eosio::asset	access:public
symbol	symbol.hpp	/^      constexpr explicit symbol( uint64_t raw ) : value(raw) {}$/;"	f	class:eosio::symbol	access:public	signature:( uint64_t raw )
symbol	symbol.hpp	/^      constexpr symbol( std::string_view ss, uint8_t precision )$/;"	f	class:eosio::symbol	access:public	signature:( std::string_view ss, uint8_t precision )
symbol	symbol.hpp	/^      constexpr symbol( symbol_code sc, uint8_t precision )$/;"	f	class:eosio::symbol	access:public	signature:( symbol_code sc, uint8_t precision )
symbol	symbol.hpp	/^      constexpr symbol() : value(0) {}$/;"	f	class:eosio::symbol	access:public	signature:()
symbol	symbol.hpp	/^      symbol symbol; \/\/\/< the symbol$/;"	m	class:eosio::extended_symbol	access:private
symbol	symbol.hpp	/^   class symbol {$/;"	c	namespace:eosio
symbol_code	symbol.hpp	/^      constexpr explicit symbol_code( std::string_view str )$/;"	f	class:eosio::symbol_code	access:public	signature:( std::string_view str )
symbol_code	symbol.hpp	/^      constexpr explicit symbol_code( uint64_t raw )$/;"	f	class:eosio::symbol_code	access:public	signature:( uint64_t raw )
symbol_code	symbol.hpp	/^      constexpr symbol_code() : value(0) {}$/;"	f	class:eosio::symbol_code	access:public	signature:()
symbol_code	symbol.hpp	/^   class symbol_code {$/;"	c	namespace:eosio
table	singleton.hpp	/^      typedef eosio::multi_index<SingletonName, row> table;$/;"	t	class:eosio::singleton	access:private
table_name	multi_index.hpp	/^               table_name   = static_cast<uint64_t>(TableName),$/;"	e	enum:eosio::multi_index::index::constants
tapos_block_num	transaction.h	/^   int tapos_block_num();$/;"	p	signature:()
tapos_block_prefix	transaction.h	/^   int tapos_block_prefix();$/;"	p	signature:()
target_block_cpu_usage_pct	privileged.hpp	/^      uint32_t target_block_cpu_usage_pct;$/;"	m	struct:eosio::blockchain_parameters	access:public
target_block_net_usage_pct	privileged.hpp	/^      uint32_t target_block_net_usage_pct;$/;"	m	struct:eosio::blockchain_parameters	access:public
tellp	datastream.hpp	/^      inline size_t tellp()const      { return size_t(_pos - _start); }$/;"	f	class:eosio::datastream	access:public	signature:() const
tellp	datastream.hpp	/^     inline size_t   tellp()const                     { return _size;             }$/;"	f	class:eosio::datastream	access:public	signature:() const
time_point	time.hpp	/^        explicit time_point( microseconds e = microseconds() ) :elapsed(e){}$/;"	f	class:eosio::time_point	access:public	signature:( microseconds e = microseconds() )
time_point	time.hpp	/^        friend class time_point;$/;"	x
time_point	time.hpp	/^  class time_point {$/;"	c	namespace:eosio
time_point_sec	time.hpp	/^        explicit time_point_sec(uint32_t seconds )$/;"	f	class:eosio::time_point_sec	access:public	signature:(uint32_t seconds )
time_point_sec	time.hpp	/^        time_point_sec( const time_point& t )$/;"	f	class:eosio::time_point_sec	access:public	signature:( const time_point& t )
time_point_sec	time.hpp	/^        time_point_sec()$/;"	f	class:eosio::time_point_sec	access:public	signature:()
time_point_sec	time.hpp	/^  class time_point_sec$/;"	c	namespace:eosio
time_since_epoch	time.hpp	/^        const microseconds& time_since_epoch()const { return elapsed; }$/;"	f	class:eosio::time_point	access:public	signature:() const
to_action	action.hpp	/^      action to_action(Args&&... args)const {$/;"	f	struct:eosio::action_wrapper	access:public	signature:(Args&&.... args) const
to_action	action.hpp	/^      action to_action(Args&&... args)const {$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Args&&.... args) const
to_const_char_arr	name.hpp	/^      struct to_const_char_arr {$/;"	s	namespace:eosio::detail
to_seconds	time.hpp	/^        int64_t to_seconds()const { return _count\/1000000; }$/;"	f	class:eosio::microseconds	access:public	signature:() const
to_string	asset.hpp	/^      std::string to_string()const {$/;"	f	struct:eosio::asset	access:public	signature:() const
to_string	name.hpp	/^      std::string to_string()const {$/;"	f	struct:eosio::name	access:public	signature:() const
to_string	symbol.hpp	/^      std::string to_string()const {$/;"	f	class:eosio::symbol_code	access:public	signature:() const
to_time_point	time.hpp	/^         time_point to_time_point() const {$/;"	f	class:eosio::block_timestamp	access:public	signature:() const
transaction	transaction.hpp	/^      transaction(time_point_sec exp = time_point_sec(now() + 60)) : transaction_header( exp ) {}$/;"	f	class:eosio::transaction	access:public	signature:(time_point_sec exp = time_point_sec(now() + 60))
transaction	transaction.hpp	/^   class transaction : public transaction_header {$/;"	c	namespace:eosio	inherits:transaction_header
transaction_extensions	transaction.hpp	/^      extensions_type      transaction_extensions;$/;"	m	class:eosio::transaction	access:public
transaction_header	transaction.hpp	/^      transaction_header( time_point_sec exp = time_point_sec(now() + 60) )$/;"	f	class:eosio::transaction_header	access:public	signature:( time_point_sec exp = time_point_sec(now() + 60) )
transaction_header	transaction.hpp	/^   class transaction_header {$/;"	c	namespace:eosio
transaction_size	transaction.h	/^   size_t transaction_size();$/;"	p	signature:()
transform_indices	multi_index.hpp	/^      static constexpr auto transform_indices( ) {$/;"	f	class:eosio::multi_index	access:private	signature:( )
true_lowest	multi_index.hpp	/^      static constexpr double true_lowest() { return -std::numeric_limits<double>::infinity(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
true_lowest	multi_index.hpp	/^      static constexpr eosio::fixed_bytes<32> true_lowest() { return eosio::fixed_bytes<32>(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
true_lowest	multi_index.hpp	/^      static constexpr eosio::key256 true_lowest() { return eosio::key256(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
true_lowest	multi_index.hpp	/^      static constexpr long double true_lowest() { return -std::numeric_limits<long double>::infinity(); }$/;"	f	struct:eosio::_multi_index_detail::secondary_key_traits	access:public	signature:()
type	action.hpp	/^      struct convert { typedef T type; };$/;"	t	struct:eosio::detail::convert	access:public
type	action.hpp	/^      struct convert<char*> { typedef std::string type; };$/;"	t	struct:eosio::detail::convert	access:public
type	action.hpp	/^      struct convert<const char*> { typedef std::string type; };$/;"	t	struct:eosio::detail::convert	access:public
type	action.hpp	/^      struct unwrap { typedef T type; };$/;"	t	struct:eosio::detail::unwrap	access:public
type	action.hpp	/^      struct unwrap<ignore<T>> { typedef T type; };$/;"	t	struct:eosio::detail::unwrap	access:public
type	crypto.hpp	/^      unsigned_int        type;$/;"	m	struct:eosio::public_key	access:public
type	crypto.hpp	/^      unsigned_int        type;$/;"	m	struct:eosio::signature	access:public
type_check	action.hpp	/^      constexpr bool type_check() {$/;"	f	namespace:eosio::detail	signature:()
unpack	datastream.hpp	/^T unpack( const char* buffer, size_t len ) {$/;"	f	namespace:eosio	signature:( const char* buffer, size_t len )
unpack	datastream.hpp	/^T unpack( const std::vector<char>& bytes ) {$/;"	f	namespace:eosio	signature:( const std::vector<char>& bytes )
unpack_action_data	action.hpp	/^   T unpack_action_data() {$/;"	f	namespace:eosio	signature:()
unpack_sent_trx	transaction.hpp	/^      transaction unpack_sent_trx() const {$/;"	f	struct:eosio::onerror	access:public	signature:() const
unsigned_int	varint.hpp	/^    unsigned_int( T v ):value(v){}$/;"	f	struct:unsigned_int	access:public	signature:( T v )
unsigned_int	varint.hpp	/^    unsigned_int( uint32_t v = 0 ):value(v){}$/;"	f	struct:unsigned_int	access:public	signature:( uint32_t v = 0 )
unsigned_int	varint.hpp	/^struct unsigned_int {$/;"	s
unsigned_int::operator !=	varint.hpp	/^    friend bool operator!=( const uint32_t& i, const unsigned_int& v )     { return i       != v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
unsigned_int::operator !=	varint.hpp	/^    friend bool operator!=( const unsigned_int& i, const uint32_t& v )     { return i.value != v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
unsigned_int::operator !=	varint.hpp	/^    friend bool operator!=( const unsigned_int& i, const unsigned_int& v ) { return i.value != v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
unsigned_int::operator <	varint.hpp	/^    friend bool operator<( const uint32_t& i, const unsigned_int& v )      { return i       < v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
unsigned_int::operator <	varint.hpp	/^    friend bool operator<( const unsigned_int& i, const uint32_t& v )      { return i.value < v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
unsigned_int::operator <	varint.hpp	/^    friend bool operator<( const unsigned_int& i, const unsigned_int& v )  { return i.value < v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
unsigned_int::operator <<	varint.hpp	/^    friend DataStream& operator << ( DataStream& ds, const unsigned_int& v ){$/;"	f	struct:unsigned_int	access:friend	signature:( DataStream& ds, const unsigned_int& v )
unsigned_int::operator =	varint.hpp	/^    unsigned_int& operator=( uint32_t v ) { value = v; return *this; }$/;"	f	struct:unsigned_int	access:public	signature:( uint32_t v )
unsigned_int::operator ==	varint.hpp	/^    friend bool operator==( const uint32_t& i, const unsigned_int& v )     { return i       == v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
unsigned_int::operator ==	varint.hpp	/^    friend bool operator==( const unsigned_int& i, const uint32_t& v )     { return i.value == v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
unsigned_int::operator ==	varint.hpp	/^    friend bool operator==( const unsigned_int& i, const unsigned_int& v ) { return i.value == v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
unsigned_int::operator >=	varint.hpp	/^    friend bool operator>=( const uint32_t& i, const unsigned_int& v )     { return i       >= v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const uint32_t& i, const unsigned_int& v )
unsigned_int::operator >=	varint.hpp	/^    friend bool operator>=( const unsigned_int& i, const uint32_t& v )     { return i.value >= v; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const uint32_t& v )
unsigned_int::operator >=	varint.hpp	/^    friend bool operator>=( const unsigned_int& i, const unsigned_int& v ) { return i.value >= v.value; }$/;"	f	struct:unsigned_int	access:friend	signature:( const unsigned_int& i, const unsigned_int& v )
unsigned_int::operator >>	varint.hpp	/^    friend DataStream& operator >> ( DataStream& ds, unsigned_int& vi ){$/;"	f	struct:unsigned_int	access:friend	signature:( DataStream& ds, unsigned_int& vi )
unsigned_int::operator T	varint.hpp	/^    operator T()const { return static_cast<T>(value); }$/;"	f	struct:unsigned_int	access:public	signature:() const
unsigned_int::unsigned_int	varint.hpp	/^    unsigned_int( T v ):value(v){}$/;"	f	struct:unsigned_int	access:public	signature:( T v )
unsigned_int::unsigned_int	varint.hpp	/^    unsigned_int( uint32_t v = 0 ):value(v){}$/;"	f	struct:unsigned_int	access:public	signature:( uint32_t v = 0 )
unsigned_int::value	varint.hpp	/^    uint32_t value;$/;"	m	struct:unsigned_int	access:public
unwrap	action.hpp	/^      struct unwrap { typedef T type; };$/;"	s	namespace:eosio::detail
unwrap	action.hpp	/^      struct unwrap<ignore<T>> { typedef T type; };$/;"	s	namespace:eosio::detail
upper_bound	multi_index.hpp	/^            const_iterator upper_bound( const secondary_key_type& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( const secondary_key_type& secondary ) const
upper_bound	multi_index.hpp	/^            const_iterator upper_bound( secondary_key_type&& secondary )const {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( secondary_key_type&& secondary ) const
upper_bound	multi_index.hpp	/^      const_iterator upper_bound( uint64_t primary )const {$/;"	f	class:eosio::multi_index	access:public	signature:( uint64_t primary ) const
utc_seconds	time.hpp	/^        uint32_t utc_seconds;$/;"	m	class:eosio::time_point_sec	access:public
valid	datastream.hpp	/^      inline bool valid()const { return _pos <= _end && _pos >= _start;  }$/;"	f	class:eosio::datastream	access:public	signature:() const
valid	datastream.hpp	/^     inline bool     valid()const                     { return true;              }$/;"	f	class:eosio::datastream	access:public	signature:() const
validate_index_name	multi_index.hpp	/^            constexpr static bool validate_index_name( eosio::name n ) {$/;"	f	struct:eosio::multi_index::index	access:public	signature:( eosio::name n )
validate_index_name	multi_index.hpp	/^            static_assert( validate_index_name( name(IndexName) ), "invalid index name used in multi_index" );$/;"	p	struct:eosio::multi_index::index	access:public	signature:(name(
validate_table_name	multi_index.hpp	/^      constexpr static bool validate_table_name( name n ) {$/;"	f	class:eosio::multi_index	access:private	signature:( name n )
validate_table_name	multi_index.hpp	/^      static_assert( validate_table_name( name(TableName) ), "multi_index does not support table names with a length greater than 12");$/;"	p	class:eosio::multi_index	access:private	signature:(name(
value	action.hpp	/^         static constexpr bool value = true;$/;"	m	struct:eosio::detail::check_types	access:public
value	action.hpp	/^      struct get_nth { static constexpr auto value  = get_nth_impl<N,0,Args...>::value; };$/;"	m	struct:eosio::detail::get_nth	access:public
value	action.hpp	/^      struct get_nth_impl { static constexpr auto value  = get_nth_impl<N,I+1,Args...>::value; };$/;"	m	struct:eosio::detail::get_nth_impl	access:public
value	action.hpp	/^      struct get_nth_impl<N, N, Arg, Args...> { static constexpr auto value = Arg; };$/;"	m	struct:eosio::detail::get_nth_impl	access:public
value	action.hpp	/^      struct is_same { static constexpr bool value = std::is_convertible<T,U>::value; };$/;"	m	struct:eosio::detail::is_same	access:public
value	action.hpp	/^      struct is_same<T,bool> { static constexpr bool value = std::is_integral<T>::value; };$/;"	m	struct:eosio::detail::is_same	access:public
value	action.hpp	/^      struct is_same<bool,U> { static constexpr bool value = std::is_integral<U>::value; };$/;"	m	struct:eosio::detail::is_same	access:public
value	binary_extension.hpp	/^         constexpr T& value()& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
value	binary_extension.hpp	/^         constexpr const T& value()const & {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
value	ignore.hpp	/^      T value;$/;"	m	struct:eosio::ignore_wrapper	access:public
value	multi_index.hpp	/^      struct intc { enum e{ value = I }; operator uint64_t()const{ return I; }  };$/;"	e	enum:eosio::multi_index::intc::e
value	name.hpp	/^         static constexpr const char value[] = {Str...};$/;"	m	struct:eosio::detail::to_const_char_arr	access:public
value	name.hpp	/^      uint64_t value = 0;$/;"	m	struct:eosio::name	access:public
value	singleton.hpp	/^         T value;$/;"	m	struct:eosio::singleton::row	access:public
value	symbol.hpp	/^      uint64_t value = 0;$/;"	m	class:eosio::symbol	access:private
value	symbol.hpp	/^      uint64_t value = 0;$/;"	m	class:eosio::symbol_code	access:private
value	varint.hpp	/^    int32_t value;$/;"	m	struct:signed_int	access:public
value	varint.hpp	/^    uint32_t value;$/;"	m	struct:unsigned_int	access:public
value_or	binary_extension.hpp	/^         constexpr T value_or()& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
value_or	binary_extension.hpp	/^         constexpr T value_or()const& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
value_or	binary_extension.hpp	/^         constexpr T&& value_or()&& {$/;"	f	class:eosio::binary_extension	access:public	signature:()
value_or	binary_extension.hpp	/^         constexpr const T&& value_or()const&& {$/;"	f	class:eosio::binary_extension	access:public	signature:() const
variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, const eosio::permission_level& perm)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, const eosio::permission_level& perm)
variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, const std::vector<eosio::permission_level>& perms)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, const std::vector<eosio::permission_level>& perms)
variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, eosio::permission_level&& perm)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, eosio::permission_level&& perm)
variant_action_wrapper	action.hpp	/^      constexpr variant_action_wrapper(Code&& code, std::vector<eosio::permission_level>&& perms)$/;"	f	struct:eosio::variant_action_wrapper	access:public	signature:(Code&& code, std::vector<eosio::permission_level>&& perms)
variant_action_wrapper	action.hpp	/^   struct variant_action_wrapper {$/;"	s	namespace:eosio
version	producer_schedule.hpp	/^      uint32_t                     version;$/;"	m	struct:eosio::producer_schedule	access:public
word_t	fixed_bytes.hpp	/^         typedef uint128_t word_t;$/;"	t	class:eosio::fixed_bytes	access:public
word_t	fixed_key.hpp	/^         typedef uint128_t word_t;$/;"	t	class:eosio::fixed_key	access:public
write	datastream.hpp	/^      inline bool write( const char* d, size_t s ) {$/;"	f	class:eosio::datastream	access:public	signature:( const char* d, size_t s )
write	datastream.hpp	/^     inline bool     write( const char* ,size_t s )  { _size += s; return true;  }$/;"	f	class:eosio::datastream	access:public	signature:( const char* ,size_t s )
write_as_string	name.hpp	/^      char* write_as_string( char* begin, char* end )const {$/;"	f	struct:eosio::name	access:public	signature:( char* begin, char* end ) const
write_as_string	symbol.hpp	/^      char* write_as_string( char* begin, char* end )const {$/;"	f	class:eosio::symbol_code	access:public	signature:( char* begin, char* end ) const
~binary_extension	binary_extension.hpp	/^         ~binary_extension() { reset(); }$/;"	f	class:eosio::binary_extension	access:public	signature:()
